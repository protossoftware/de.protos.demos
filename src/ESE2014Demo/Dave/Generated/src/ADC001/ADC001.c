/*******************************************************************************
**  DAVE App Name : ADC001       App Version: 1.0.22               
**  This file is generated by DAVE, User modification to this file will be    **
**  overwritten at the next code generation.                                  **
*******************************************************************************/

/*CODE_BLOCK_BEGIN[ADC001.c]*/

/*******************************************************************************
 Copyright (c) 2013, Infineon Technologies AG                                 **
 All rights reserved.                                                         **
                                                                              **
 Redistribution and use in source and binary forms, with or without           **
 modification,are permitted provided that the following conditions are met:   **
                                                                              **
 *Redistributions of source code must retain the above copyright notice,      **
 this list of conditions and the following disclaimer.                        **
 *Redistributions in binary form must reproduce the above copyright notice,   **
 this list of conditions and the following disclaimer in the documentation    **
 and/or other materials provided with the distribution.                       **
 *Neither the name of the copyright holders nor the names of its contributors **
 may be used to endorse or promote products derived from this software without**
 specific prior written permission.                                           **
                                                                              **
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  **
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **
 ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **
 LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **
 SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **
 CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **
 POSSIBILITY OF SUCH DAMAGE.                                                  **
                                                                              **
 To improve the quality of the software, users are encouraged to share        **
 modifications, enhancements or bug fixes with Infineon Technologies AG       **
 dave@infineon.com).                                                          **
                                                                              **
********************************************************************************
**                                                                            **
**                                                                            **
** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **
**                                                                            **
** COMPILER : Compiler Independent                                            **
**                                                                            **
** AUTHOR   : DAVE App Developer                                              **
**                                                                            **
** MAY BE CHANGED BY USER [yes/no]: Yes                                       **
**                                                                            **
** MODIFICATION DATE : Jan 29, 2014                                           **
**                                                                            **
*******************************************************************************/

/*******************************************************************************
**                      Author(s) Identity                                    **
********************************************************************************
**                                                                            **
** Initials     Name                                                          **
** CM           DAVE App Developer                                            **
** SSAM         Sridhar Sampath                                               **
** ---------------------------------------------------------------------------**

*******************************************************************************/


/**
 * @file ADC001.c
 *
 * @brief This file contains ADC001 App API definitions
 *
 * Change History:
 *  Date       version       Details
 * 16-Dec-2012   1.0.4    Initial code added for XMC1000
 * 06-Mar-2013   1.0.6    App version changed for XMC1000 and XMC4400/XMC4200
 * 24-Apr-2013   1.0.8    Ported to XMC4500 step AB and
 *                        Source Result selection Feature added
 * 11-Jun-2013   1.0.10   1. In channel selection page Group C and Group D check
 *                        boxes made invisible for XMC1200/1300/4200 devices.
 *                        2. In the Header comment section device name changed
 *                           to XMC1000.
 *                        3. Tooltip for the Group channel selection is modified
 *                        4. New api ADC001_GetFastResult() implemented.
 *                        5. Source Result register selection feature disabled
 *                           due to header file update not available.
 * 27-Jun-2013   1.0.12   Source Result register selection feature removed to
 *                        simplify the app.
 * 27-Sep-2013   1.0.16   Typos in API Documentation & .h comments is corrected.
 * 29-Jan-2014   1.0.18   Error codes are added in various functions,
 *                        that can be logged with DBG002 App.
 */

/*******************************************************************************
 ** INCLUDE FILES                                                             **
 ******************************************************************************/
#include <DAVE3.h>


/*****************************************************************************
              DUMMY DEFINTIONS OF DEBUG LOG MACROS
*****************************************************************************/
/*These definitions are included here to avoid compilation errors,
 since the DBG002 app is not part of the project. All the macros are defined
 as empty*/
#ifndef _DBG002_H_

#define DBG002_RegisterCallBack(A,B,C)
#define DBG002_I(e)
#define DBG002_IG(e,g)
#define DBG002_IH(e,h)
#define DBG002_IP(e,p)
#define DBG002_IGH(e,g,h)
#define DBG002_IGP(e,g,p)
#define DBG002_IHP(e,h,p)
#define DBG002_IGHP(e,g,h,p)
#define DBG002_N(e)
#define DBG002_NG(e,g)
#define DBG002_NH(e,h)
#define DBG002_NP(e,p)
#define DBG002_NGH(e,g,h)
#define DBG002_NGP(e,g,p)
#define DBG002_NHP(e,h,p)
#define DBG002_NGHP(e,g,h,p)
#define DBG002_ID(e)
#define DBG002_IS(e)
#define DBG002_ISG(e,g)
#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)
#define DBG002_CRITICAL(groupid,messageid,length,value)
#define DBG002_ERROR(groupid,messageid,length,value)
#define DBG002_WARNING(groupid,messageid,length,value)
#define DBG002_INFO(groupid,messageid,length,value)
#define DBG002_TRACE(groupid,messageid,length,value)
#define DBG002_FUNCTION_ENTRY(GID, Status)
#define DBG002_FUNCTION_EXIT(GID, Status)

#define DBG002_MESSAGEID_LITERAL

#endif/* End of defintions of dummy Debug Log macros*/

/*******************************************************************************
**                      Private Macro Definitions                             **
*******************************************************************************/
#define APP_GID DBG002_GID_ADC001

/**
 * @cond INTERNAL_DOCS
 */
/*******************************************************************************
**                      Private Type Definitions                              **
*******************************************************************************/

/*******************************************************************************
**                 Private Function Declarations:
*******************************************************************************/
/**
 * @brief This function initialises  the app.
 *
 * @param [in] HandlePtr pointer to the Instance variable<BR>
 *
 * @return  NOne <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */

void ADC001_lInit(const ADC001_HandleType *HandlePtr );

/*******************************************************************************
**                      Global Constant Definitions                           **
*******************************************************************************/

/*******************************************************************************
**                      Global Variable Definitions                           **
*******************************************************************************/

/*******************************************************************************
**                      Private Constant Definitions                          **
*******************************************************************************/

/*******************************************************************************
**                 Function like macro definitions                            **
*******************************************************************************/

/*******************************************************************************
**                      Private Function Definitions                          **
*******************************************************************************/

/*******************************************************************************
**                      Public Function Definitions                           **
*******************************************************************************/


/** This function initializes the app */
void ADC001_Init(void)
{
  /*Initialize the global app */
  ADCGLOB001_Init();
  ADC001_lInit(&ADC001_Handle0);
}

/*
 * This Function initializes the ADC001 App.
 */
void ADC001_lInit(const ADC001_HandleType *HandlePtr )
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;

  uint8_t GroupNo;
  uint8_t ChNo;
  uint8_t ChIdx;
  uint8_t GroupIdx;

  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr[4];

  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;
  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;
  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;
  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if((HandlePtr->DynamicHandlePtr->State == ADC001_UNINITIALIZED))
  {

    for(ChIdx = (uint8_t)0; ChIdx < (uint8_t)HandlePtr->kChannels; ChIdx++)
    {
      GroupNo = ADC001_ChannelHandlePtr[ChIdx]->kGroupNo;
      ChNo = ADC001_ChannelHandlePtr[ChIdx]->kChannelNo;
      /* Input class */
      WR_REG( VADCGroupPtr[GroupNo]->CHCTR[ChNo],
        VADC_G_CHCTR_ICLSEL_Msk,
        VADC_G_CHCTR_ICLSEL_Pos,
        (uint32_t)HandlePtr->kIpClassSel
       );

      /* Store result in global register */
      WR_REG( VADCGroupPtr[GroupNo]->CHCTR[ChNo],
              VADC_G_CHCTR_RESTBS_Msk,
              VADC_G_CHCTR_RESTBS_Pos,
              (uint32_t)1
             );

      /*Result Alignment */
      WR_REG( VADCGroupPtr[GroupNo]->CHCTR[ChNo],
              VADC_G_CHCTR_RESPOS_Msk,
              VADC_G_CHCTR_RESPOS_Pos,
              (uint32_t)HandlePtr->kResultControl
             );
    }

    /* Wait for read mode */
    WR_REG( VADCGlobalPtr->GLOBRCR,
            VADC_GLOBRCR_WFR_Msk,
            VADC_GLOBRCR_WFR_Pos,
            (uint32_t)HandlePtr->kResultReadMode
           );

    /* Result event service request  */
    WR_REG( VADCGlobalPtr->GLOBRCR,
            VADC_GLOBRCR_SRGEN_Msk,
            VADC_GLOBRCR_SRGEN_Pos,
            (uint32_t)HandlePtr->kResultEvtEnable
           );

    /* Select the input channels sequence */
    VADCGlobalPtr->BRSSEL[0] =  HandlePtr->kGroup0ChSelect;
    VADCGlobalPtr->BRSSEL[1] =  HandlePtr->kGroup1ChSelect;
    VADCGlobalPtr->BRSSEL[2] =  HandlePtr->kGroup2ChSelect;
    VADCGlobalPtr->BRSSEL[3] =  HandlePtr->kGroup3ChSelect;

    /*
     * Enable XTWC Bitfield so that XTMODE and XTSEL can be written
     * Selects trigger mode .
     */
    VADCGlobalPtr->BRSCTRL |= (uint32_t)(((uint32_t)1 << VADC_BRSCTRL_XTWC_Pos)    |  \
                      ((uint32_t)HandlePtr->kTriggerMode << VADC_BRSCTRL_XTMODE_Pos));
    /*
     * Selects the gating mode and enables trigger mode.
     * AutoScan enable or disable
     * Source interrupt enable or disable
     */
    VADCGlobalPtr->BRSMR |=(uint32_t)(((uint32_t)HandlePtr->kTriggerEn            \
                                                      << VADC_BRSMR_ENTR_Pos) |   \
                                    ((uint32_t)HandlePtr->kGatingMode             \
                                                      << VADC_BRSMR_ENGT_Pos) |   \
                                    ((uint32_t)HandlePtr->kAutoScan               \
                                                      << VADC_BRSMR_SCAN_Pos) |   \
                                    ((uint32_t)HandlePtr->kResourceEvtEnable      \
                                                      << VADC_BRSMR_ENSI_Pos));

    /*
     * Enable Arbitration slot.
     * Select conversion start mode for request source.
     * Sets the priority of the background request source.
     */
    for(GroupIdx = (uint8_t)0; GroupIdx < (uint8_t)ADC001_MAX_ADC_GROUP; GroupIdx++)
    {
      if(HandlePtr->kActiveGroups[GroupIdx] == (uint8_t)1)
      {
        VADCGroupPtr[GroupIdx]->ARBPR |= (uint32_t)(((uint32_t)HandlePtr->kAsenEnable <<  \
                                                         VADC_G_ARBPR_ASEN2_Pos) |        \
                                          ((uint32_t)HandlePtr->kStartmode   <<           \
                                                         VADC_G_ARBPR_CSM2_Pos)  |        \
                                          ((uint32_t)HandlePtr->kPriority    <<           \
                                                         VADC_G_ARBPR_PRIO2_Pos));
      }
    }

    /* change the state to the Initialized */
    HandlePtr->DynamicHandlePtr->State = ADC001_INITIALIZED;
    Status &= (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

}


/**
 * This function resets the App.
 */
status_t ADC001_Deinit(const ADC001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  uint8_t GroupNo;
  uint8_t ChNo;
  uint8_t ChIdx;
  uint8_t GroupIdx;

  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr[4];

  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;
  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;
  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;
  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if((HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED))
  {

    for(ChIdx = (uint8_t)0; ChIdx < (uint8_t)HandlePtr->kChannels; ChIdx++)
    {
      GroupNo = (uint8_t )ADC001_ChannelHandlePtr[ChIdx]->kGroupNo;
      ChNo = (uint8_t )ADC001_ChannelHandlePtr[ChIdx]->kChannelNo;
      VADCGroupPtr[GroupNo]->CHCTR[ChNo] = (uint32_t )0;
    }

    VADCGlobalPtr->GLOBRCR = (uint32_t )0;

    /* Select the input channels sequence */
    VADCGlobalPtr->BRSSEL[0] =  (uint32_t )0;
    VADCGlobalPtr->BRSSEL[1] =  (uint32_t )0;
    VADCGlobalPtr->BRSSEL[2] =  (uint32_t )0;
    VADCGlobalPtr->BRSSEL[3] =  (uint32_t )0;
    VADCGlobalPtr->BRSCTRL = (uint32_t )0x00808000;

    VADCGlobalPtr->BRSMR = (uint32_t )0;

    /*
     * Enable Arbitration slot.
     * Select conversion start mode for request source.
     * Sets the priority of the background request source.
     */
    for(GroupIdx = (uint8_t )0; GroupIdx < (uint8_t )ADC001_MAX_ADC_GROUP; GroupIdx++)
    {
      if(HandlePtr->kActiveGroups[GroupIdx] == (uint8_t)1)
      {
        VADCGroupPtr[GroupIdx]->ARBPR = (uint32_t )0;
      }
    }

    Status = (uint32_t)DAVEApp_SUCCESS;
    HandlePtr->DynamicHandlePtr->State = ADC001_UNINITIALIZED;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function selects the input class for the channel.
 */
status_t ADC001_SelectInputClass(const ADC001_HandleType* HandlePtr,
                                                  ADC001_GlobalInPutClass Class)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  uint8_t GroupNo;
  uint8_t ChNo;
  uint8_t ChIdx;

  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr[4];

  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;
  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;
  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;
  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;
  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if((Class == ADC001_GLOBAL_CLASS0) || (Class == ADC001_GLOBAL_CLASS1))
    {
      for(ChIdx = (uint8_t)0; ChIdx < (uint8_t)HandlePtr->kChannels; ChIdx++)
      {
        GroupNo = ADC001_ChannelHandlePtr[ChIdx]->kGroupNo;
        ChNo = ADC001_ChannelHandlePtr[ChIdx]->kChannelNo;

        /* Input class */
        WR_REG( VADCGroupPtr[GroupNo]->CHCTR[ChNo],
          VADC_G_CHCTR_ICLSEL_Msk,
          VADC_G_CHCTR_ICLSEL_Pos,
          (uint32_t)Class
         );
      }
      Status = (uint8_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function enables the service request after result event.
 */
status_t ADC001_EnableResultEvt(const ADC001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)
  {
    /* Enable Result event service request  */
    SET_BIT( VADCGlobalPtr->GLOBRCR, VADC_GLOBRCR_SRGEN_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function disables the service request after result event.
 */
status_t ADC001_DisableResultEvt(const ADC001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)
  {
    /* Disables Result event service request  */
    CLR_BIT( VADCGlobalPtr->GLOBRCR, VADC_GLOBRCR_SRGEN_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function returns the result of the normal mode ADC conversion.
 */
status_t ADC001_GetResult(const ADC001_HandleType* HandlePtr,
                                            ADC001_ResultHandleType* ResultPtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  uint32_t ADCResult;

  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(ResultPtr != NULL)
    {
      ADCResult = VADCGlobalPtr->GLOBRES;
      /* If valid flag is set */
      if(((ADCResult & VADC_GLOBRES_VF_Msk) >> VADC_GLOBRES_VF_Pos) == (uint32_t)1)
      {
          ResultPtr->GroupNo = (uint8_t)((ADCResult & VADC_GLOBRES_GNR_Msk) >> VADC_GLOBRES_GNR_Pos);
          ResultPtr->ChannelNo = (uint8_t)((ADCResult & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Pos);
          ResultPtr->Result = (uint16_t)(ADCResult & VADC_GLOBRES_RESULT_Msk);
          Status = (uint32_t)DAVEApp_SUCCESS;
      }
      /* If data is old, then send error as invalid data */
      else
      {
        Status = (uint32_t)ADC001_INVALID_RESULT;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function returns the result of the normal mode ADC conversion without checking the valid bitfield.
 */
uint16_t ADC001_GetFastResult(const ADC001_HandleType* HandlePtr)
{

    /* Pointer to the VADC Kernel Structure */
    VADC_GLOBAL_TypeDef *VADCGlobalPtr;
     VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

    return (uint16_t)(VADCGlobalPtr->GLOBRES & (uint32_t)VADC_GLOBRES_RESULT_Msk);
}


/**
 * This function checks whether Result event flag is set.
 */
status_t ADC001_GetResultEvtFlag(const ADC001_HandleType* HandlePtr,
                                                            uint8_t* EvtStatus)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)
  {
    if(EvtStatus != NULL)
    {
      *EvtStatus = (uint8_t)RD_REG( VADCGlobalPtr->GLOBEFLAG,
                          VADC_GLOBEFLAG_REVGLB_Msk, VADC_GLOBEFLAG_REVGLB_Pos);
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This will set the result event flag through software.
 */
status_t ADC001_SetResultEvtFlag(const ADC001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)
  {
    SET_BIT( VADCGlobalPtr->GLOBEFLAG,
             VADC_GLOBEFLAG_REVGLB_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function clears the pending result event flag
 */
status_t ADC001_ClearResultEvtFlag(const ADC001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)
  {
    SET_BIT( VADCGlobalPtr->GLOBEFLAG,
             VADC_GLOBEFLAG_REVGLBCLR_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function checks whether Channel event flag is set.
 */
status_t ADC001_GetChannelEvtFlag(const ADC001_HandleType* HandlePtr,
                                  uint8_t* EvtStatus,
                                  const ADC001_ChannelHandleType* ChannelPtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  uint8_t GroupNo;
  uint8_t ChannelNo;

  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr[4];

  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;
  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;
  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;
  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;
  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if((ChannelPtr != NULL) && (EvtStatus != NULL))
    {
      GroupNo = ChannelPtr->kGroupNo;
      ChannelNo = ChannelPtr->kChannelNo;
      if((GroupNo < (uint8_t)ADC001_MAX_ADC_GROUP) &&
          (ChannelNo < (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&
            (HandlePtr->kActiveGroups[GroupNo] == (uint8_t)1) &&
              (HandlePtr->kActiveChannels[GroupNo][ChannelNo] == (uint8_t)1))
      {
        *EvtStatus = (uint8_t)RD_REG(VADCGroupPtr[GroupNo]->CEFLAG,
                      ((uint32_t)0x01 << ChannelNo),
                      ChannelNo);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      else
      {
        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function sets the channel event flags through software.
 */
status_t ADC001_SetChannelEvtFlag(const ADC001_HandleType* HandlePtr,
                                  const ADC001_ChannelHandleType* ChannelPtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  uint8_t GroupNo;
  uint8_t ChannelNo;

  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr[4];

  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;
  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;
  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;
  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;
  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(ChannelPtr != NULL)
    {
      GroupNo = ChannelPtr->kGroupNo;
      ChannelNo = ChannelPtr->kChannelNo;
      if((GroupNo < (uint8_t)ADC001_MAX_ADC_GROUP) &&
          (ChannelNo < (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&
            (HandlePtr->kActiveGroups[GroupNo] == (uint8_t)1) &&
              (HandlePtr->kActiveChannels[GroupNo][ChannelNo] == (uint8_t)1))
      {
        SET_BIT( VADCGroupPtr[GroupNo]->CEFLAG, ChannelNo);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      else
      {
        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function clears the pending channel event flag.
 */
status_t ADC001_ClearChannelEvtFlag(const ADC001_HandleType* HandlePtr,
                                    const ADC001_ChannelHandleType* ChannelPtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  uint8_t GroupNo;
  uint8_t ChannelNo;

  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr[4];

  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;
  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;
  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;
  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;
  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(ChannelPtr != NULL)
    {
      GroupNo = ChannelPtr->kGroupNo;
      ChannelNo = ChannelPtr->kChannelNo;
      if((GroupNo < (uint8_t)ADC001_MAX_ADC_GROUP) &&
          (ChannelNo < (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&
            (HandlePtr->kActiveGroups[GroupNo] == (uint8_t)1) &&
              (HandlePtr->kActiveChannels[GroupNo][ChannelNo] == (uint8_t)1))
      {
        SET_BIT( VADCGroupPtr[GroupNo]->CEFCLR, ChannelNo);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      else
      {
        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This function enables the service request after background request
 * source event.
 */
status_t ADC001_EnableBackGroundEvent(const ADC001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)
  {
    /* Enable background request source event service request  */
    SET_BIT( VADCGlobalPtr->BRSMR,
             VADC_BRSMR_ENSI_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function disables the service request after background request
 * source event.
 */
status_t ADC001_DisableBackGroundEvent(const ADC001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)
  {
    /* Disable background request source event service request */
    CLR_BIT( VADCGlobalPtr->BRSMR,
             VADC_BRSMR_ENSI_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This function checks whether source event flag is set.
 */
status_t ADC001_GetBackGroundEvtFlag(const ADC001_HandleType* HandlePtr,
                                                            uint8_t* EvtStatus)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(EvtStatus != NULL)
    {
      *EvtStatus = (uint8_t)RD_REG( VADCGlobalPtr->GLOBEFLAG,
                          VADC_GLOBEFLAG_SEVGLB_Msk,
                          VADC_GLOBEFLAG_SEVGLB_Pos
                   );
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This function sets the source event flag through software.
 */
status_t ADC001_SetBackGroundEvtFlag(const ADC001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)
  {
    SET_BIT( VADCGlobalPtr->GLOBEFLAG,
             VADC_GLOBEFLAG_SEVGLB_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function clears the pending source event flag.
 */
status_t ADC001_ClearBackGroundEvtFlag(const ADC001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)
  {
    SET_BIT( VADCGlobalPtr->GLOBEFLAG,
             VADC_GLOBEFLAG_SEVGLBCLR_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/* This function clears pending bits.*/
status_t ADC001_ClearPendingBits(const ADC001_HandleType *HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    /* Clear Pending Bits */
    SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_CLRPND_Pos);

    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/* This function generates a load event.*/
status_t ADC001_GenerateLoadEvent(const ADC001_HandleType *HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    /* Generate load event */
    SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_LDEV_Pos);

    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 * This function enables the gating.
 */
status_t ADC001_EnableGate(const ADC001_HandleType *HandlePtr,
                                                  uint8_t GateSelectVal)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(GateSelectVal <= (uint8_t)ADC001_GATING_ENABLED_FOR_LOW)
    {
      /* Selects the gating functionality */
     WR_REG(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENGT_Msk, VADC_BRSMR_ENGT_Pos,
                                                      (uint8_t)GateSelectVal);
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This function gives the selected gate input level.
 */
status_t ADC001_GetGateLevel(const ADC001_HandleType* HandlePtr,
                                                            uint8_t* GeteLvlPtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(GeteLvlPtr != NULL)
    {
      *GeteLvlPtr = (uint8_t)RD_REG( VADCGlobalPtr->BRSMR,
                                     VADC_BRSMR_REQGT_Msk,
                                     VADC_BRSMR_REQGT_Pos
                                   );
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 * This function sets the external trigger mode.
 */
status_t ADC001_SetExternalTriggerMode(const ADC001_HandleType *HandlePtr,
                                                         uint8_t TriggerMode)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  uint32_t ModeSelect;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(TriggerMode <= (uint8_t)ADC001_TRIGGER_UPON_BOTH_EDGE)
    {
      if(TriggerMode == (uint8_t)ADC001_NOTRIGGER)
      {
        /* Disables external trigger */
        CLR_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENTR_Pos);
      }
      else
      {
        /* Enables external trigger */
        SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENTR_Pos);
      }
      /* Sets the external trigger mode */
      ModeSelect = VADCGlobalPtr->BRSCTRL;
      ModeSelect &= ~VADC_BRSCTRL_XTMODE_Msk;
      ModeSelect |= (uint32_t)(((uint32_t)1 << VADC_BRSCTRL_XTWC_Pos) |
                ((uint32_t)TriggerMode << VADC_BRSCTRL_XTMODE_Pos));
      VADCGlobalPtr->BRSCTRL = ModeSelect;
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 * This function enables external trigger.
 */
status_t ADC001_EnableExternalTrigger(const ADC001_HandleType *HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    /* Enables external trigger */
    SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENTR_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 * This function disables external trigger.
 */
status_t ADC001_DisableExternalTrigger(const ADC001_HandleType *HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    /* Disables external trigger */
    CLR_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENTR_Pos);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/*
 * This function enables arbitration slot.
 */
status_t ADC001_EnableArbitrationSlot(const ADC001_HandleType *HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  uint8_t GroupIdx;

  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr[4];

  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;
  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;
  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;
  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    for(GroupIdx = (uint8_t)0; GroupIdx < (uint8_t)ADC001_MAX_ADC_GROUP; GroupIdx++)
    {
      if(HandlePtr->kActiveGroups[GroupIdx] == (uint8_t)1)
      {
        SET_BIT(VADCGroupPtr[GroupIdx]->ARBPR, VADC_G_ARBPR_ASEN2_Pos);
      }
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 * This function disables external trigger.
 */
status_t ADC001_DisableArbitrationSlot(const ADC001_HandleType *HandlePtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  uint8_t GroupIdx;
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr[4];

  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;
  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;
  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;
  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    for(GroupIdx = (uint8_t)0; GroupIdx < (uint8_t)ADC001_MAX_ADC_GROUP; GroupIdx++)
    {
      if(HandlePtr->kActiveGroups[GroupIdx] == (uint8_t)1)
      {
        CLR_BIT(VADCGroupPtr[GroupIdx]->ARBPR, VADC_G_ARBPR_ASEN2_Pos);
      }
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}
/*
 * This function sets the Autoscan Source Load Event Mode.
 * Overwrite Mode or Combine Mode can be selected.
 */
status_t ADC001_SetLoadEventMode(const ADC001_HandleType *HandlePtr,
                                                            uint8_t EventMode)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(EventMode == (uint8_t)ADC001_OVERWRITE_MODE)
    {
      /* Set OverWrite Mode */
      CLR_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_LDM_Pos);
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else if(EventMode == (uint8_t)ADC001_COMBINE_MODE)
    {
      /* Set Combine Mode */
      SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_LDM_Pos);
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 * This function sets the required channel in channel pending register.
 */
status_t ADC001_SetPendingChannel(const ADC001_HandleType *HandlePtr,
                                  const ADC001_ChannelHandleType* ChannelPtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  uint8_t GroupNo;
  uint8_t ChannelNo;
  uint8_t GroupNoAct;
  uint8_t ChannelNoAct;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(ChannelPtr != NULL)
    {
      GroupNo = ChannelPtr->kGroupNo;
      ChannelNo = ChannelPtr->kChannelNo;
      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];
      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];

      if((GroupNo <= (uint8_t)ADC001_MAX_ADC_GROUP) &&
          (ChannelNo <= (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&
            (GroupNoAct == (uint8_t)1) && (ChannelNoAct == (uint8_t)1))
      {
        /*set the channel*/
        SET_BIT(VADCGlobalPtr->BRSPND[GroupNo], ChannelNo);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      else
      {
        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/*
 * This function clears the required channel in channel pending register.
 */
status_t ADC001_ClearPendingChannel(const ADC001_HandleType *HandlePtr,
                                    const ADC001_ChannelHandleType* ChannelPtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  uint8_t GroupNo;
  uint8_t ChannelNo;
  uint8_t GroupNoAct;
  uint8_t ChannelNoAct;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(ChannelPtr != NULL)
    {
      GroupNo = ChannelPtr->kGroupNo;
      ChannelNo = ChannelPtr->kChannelNo;
      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];
      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];

      if((GroupNo <= (uint8_t)ADC001_MAX_ADC_GROUP) &&
            (ChannelNo <= (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&
              (GroupNoAct == (uint8_t)1) &&(ChannelNoAct == (uint8_t)1))
      {
        /*Set the channel*/
        CLR_BIT(VADCGlobalPtr->BRSPND[GroupNo], ChannelNo);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      else
      {
        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/*
 *This function sets the required channel in channel pending register.
 */
status_t ADC001_SetChannelSelect(const ADC001_HandleType *HandlePtr,
                                 const ADC001_ChannelHandleType* ChannelPtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  uint8_t GroupNo;
  uint8_t ChannelNo;
  uint8_t GroupNoAct;
  uint8_t ChannelNoAct;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(ChannelPtr != NULL)
    {
      GroupNo = ChannelPtr->kGroupNo;
      ChannelNo = ChannelPtr->kChannelNo;
      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];
      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];

      if((GroupNo <= (uint8_t)ADC001_MAX_ADC_GROUP) &&
          (ChannelNo <= (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&
            (GroupNoAct == (uint8_t)1) &&(ChannelNoAct == (uint8_t)1))
      {
        /*set the channel*/
        SET_BIT(VADCGlobalPtr->BRSSEL[GroupNo], ChannelNo);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      else
      {
        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/*
 * This function clears the required channel in channel pending register.
 */
status_t ADC001_ClearChannelSelect(const ADC001_HandleType *HandlePtr,
                                   const ADC001_ChannelHandleType* ChannelPtr)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;
  uint8_t GroupNo;
  uint8_t ChannelNo;
  uint8_t GroupNoAct;
  uint8_t ChannelNoAct;

  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;

  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(ChannelPtr != NULL)
    {
      GroupNo = ChannelPtr->kGroupNo;
      ChannelNo = ChannelPtr->kChannelNo;
      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];
      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];

      if((GroupNo <= (uint8_t)ADC001_MAX_ADC_GROUP) &&
          (ChannelNo <= (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&
            (GroupNoAct == (uint8_t)1) &&
              (ChannelNoAct == (uint8_t)1))
      {
        /*Set the channel*/
        CLR_BIT(VADCGlobalPtr->BRSSEL[GroupNo], ChannelNo);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      else
      {
        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/*
 *This function sets the channel event mode.
 */
status_t ADC001_SetChannelEventMode(const ADC001_HandleType *HandlePtr,
                                    const ADC001_ChannelHandleType* ChannelPtr,
                                    uint8_t EventMode)
{
  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;
  uint8_t GroupNo;
  uint8_t ChannelNo;
  uint8_t GroupNoAct;
  uint8_t ChannelNoAct;

  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr[4];

  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;
  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;
  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;
  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;

  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)
  {
    if(ChannelPtr != NULL)
    {
      GroupNo = ChannelPtr->kGroupNo;
      ChannelNo = ChannelPtr->kChannelNo;
      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];
      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];

      if((GroupNo <= (uint8_t)ADC001_MAX_ADC_GROUP) &&
          (ChannelNo <= (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&
            (GroupNoAct == (uint8_t)1) &&
              (ChannelNoAct == (uint8_t)1) &&
                ((EventMode == (uint8_t)ADC001_CHANNEL_EVENT_NEVER) ||
                    (EventMode == (uint8_t)ADC001_CHANNEL_EVENT_ALWAYS)))
      {
        WR_REG( VADCGroupPtr[GroupNo]->CHCTR[ChannelNo],
          VADC_G_CHCTR_CHEVMODE_Msk,
          VADC_G_CHCTR_CHEVMODE_Pos,
          (uint32_t)EventMode
         );
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      else
      {
        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }
    }
    else
    {
      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}
/**
 * @endcond
 */
/*CODE_BLOCK_END*/

