package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class adcglob001h_template
{
  protected static String nl;
  public static synchronized adcglob001h_template create(String lineSeparator)
  {
    nl = lineSeparator;
    adcglob001h_template result = new adcglob001h_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/******************************************************************************" + NL + " *" + NL + " * Copyright (C) 2014 Infineon Technologies AG. All rights reserved." + NL + " *" + NL + " * Infineon Technologies AG (Infineon) is supplying this software for use with" + NL + " * Infineon's microcontrollers." + NL + " * This file can be freely distributed within development tools that are" + NL + " * supporting such microcontrollers." + NL + " *" + NL + " * THIS SOFTWARE IS PROVIDED \"AS IS\".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED" + NL + " * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF" + NL + " * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE." + NL + " * INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL," + NL + " * OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER." + NL + " *" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR   : DAVE App Developer                                              **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE :  25 Apr 2013                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** PA           DAVE App Developer                                      **" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @file ADCGlob001.h" + NL + " * @brief  This file contains interfaces for the global ADC App." + NL + " *" + NL + " * Change History:" + NL + " * Date       version       Details" + NL + " * 12-Dec-2012   1.0.5    Initial code added for XMC1000" + NL + " * 18-Jan-2013   1.0.6    Merging with XMC1000 done" + NL + " * 24-Apr-2013   1.0.12   Ported to XMC4500 step AB and" + NL + " *                        Source Result selection Feature added" + NL + " * 10-Jun-2013   1.0.14   1. Supported for XMC1100 device,  " + NL + " *                        2. Comment in header section - the Device series name is" + NL + " *                           made as XMC1000" + NL + " * 27-Jun-2013   1.0.16   Global limits made unavailable for adc004 app" + NL + " * 29-Aug-2013   1.0.18   XMC1200/XMC1300 New Sofware IDS added." + NL + " *                        Unused code removed" + NL + " * 31-Oct-2013   1.0.20   1. The macro name ADCGLOB001_DBG002_FUNCTION_ENTRY is " + NL + " *                        corrected as ADCGLOB001_FUNCTION_ENTRY " + NL + " *                        2. Analog Clock divider value minimum 1 was generated" + NL + " *                        and now it is made as 0 for XMC1000 devices." + NL + " * 14-Nov-2013   1.0.22   CLK001_Init() for XMC4000 devices CLK002_Init() for " + NL + " *                        XMC1000 devices is removed in ADCGLOB001_Init() " + NL + " *                        function, since this CLK00x_Init() function is called" + NL + " *                        at the beginning  of the DAVE_Init() function. " + NL + " * 25-Apr-2014   1.0.28   Double clock for MSB conversion option removed," + NL + " *                        Sampling time calculation for XMC1 devices modified with accelerated mode," + NL + " *                        Startup calibration API Modified." + NL + " */" + NL + "" + NL + "#ifndef ADCGLOB001_H_" + NL + "#define ADCGLOB001_H_" + NL + "" + NL + "#ifdef __cplusplus" + NL + "extern \"C\" {" + NL + "#endif" + NL + "" + NL + "/*******************************************************************************" + NL + " ** INCLUDE FILES                                                             **" + NL + " ******************************************************************************/" + NL + "" + NL + "#include <DAVE3.h>" + NL + "" + NL + "" + NL + "/**" + NL + "  * @ingroup ADCGLOB001_publicparam" + NL + "  * @{" + NL + "  */" + NL + "/*******************************************************************************" + NL + " *                                ENUMERATIONS                                **" + NL + " ******************************************************************************/" + NL + "/**" + NL + " * This enumerates the error codes of the ADC Global App" + NL + " */" + NL + "typedef enum ADCGlob001_ErrorType" + NL + "{" + NL + "  /**" + NL + "   * The operation is not allowed." + NL + "   */" + NL + "  ADCGLOB001_OPER_NOT_ALLOWED = 1," + NL + "  /**" + NL + "   * This error code means that the parameters passed to an API are invalid" + NL + "   */" + NL + "" + NL + "  ADCGLOB001_INVALID_PARAM_ERROR," + NL + "" + NL + "  /**" + NL + "   * Debug log code for function entry" + NL + "   */" + NL + "  ADCGLOB001_FUNCTION_ENTRY," + NL + "" + NL + "  /**" + NL + "   * Debug log code for function exit" + NL + "   */" + NL + "  ADCGLOB001_FUNCTION_EXIT," + NL + "  " + NL + "}ADCGlob001_ErrorType;" + NL + "" + NL + "/**" + NL + " *This enumerates the app state." + NL + " */" + NL + "typedef enum ADCGLOB001_StateType{" + NL + "  /**" + NL + "   * This is the default state after power on reset" + NL + "   */" + NL + "  ADCGLOB001_UNINITIALIZED," + NL + "  /**" + NL + "   * This is the INITIALIZED state in which APP is initialized as per selected" + NL + "   * parameters." + NL + "  */" + NL + "  ADCGLOB001_INITIALIZED," + NL + "" + NL + "} ADCGLOB001_StateType;" + NL + "" + NL + "/**" + NL + " * This enumerates the conversion mode" + NL + " */" + NL + "typedef enum ADCGLOB001_ConversionMode{" + NL + "    /**" + NL + "     * 12-bit conversion" + NL + "     */" + NL + "  ADCGLOB001_12BIT = 0," + NL + "    /**" + NL + "     * 10-bit conversion" + NL + "     */" + NL + "  ADCGLOB001_10BIT=1," + NL + "    /**" + NL + "     * 8-bit conversion" + NL + "     */" + NL + "  ADCGLOB001_8BIT=2," + NL + "    /**" + NL + "     * 10-bit fast compare mode" + NL + "     */    " + NL + "  ADCGLOB001_10BITFAST = 5" + NL + "  " + NL + "}ADCGLOB001_ConversionMode;" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + " *                             STRUCTURES                                     **" + NL + " ******************************************************************************/" + NL + "/**" + NL + " * This structure holds the VADC Global parameters which change at run" + NL + " * time." + NL + " */" + NL + "" + NL + "typedef struct ADCGLOB001_DynamicDataType{" + NL + "" + NL + "  /**" + NL + "   * This parameter tells the state of App." + NL + "   */ " + NL + "  ADCGLOB001_StateType StateType;" + NL + "" + NL + "}ADCGLOB001_DynamicDataType;" + NL + "" + NL + "/**" + NL + " * This structure holds the GUI configurable parameters of this app." + NL + " */" + NL + "typedef struct ADCGLOB001_HandleType{" + NL + "/**" + NL + " * This is the register structure pointer to the VADC kernel." + NL + " */" + NL + "  VADC_GLOBAL_TypeDef* const kGlobalPtr;" + NL + "/**" + NL + " * This is the pointer to the Dynamic Handle of the App." + NL + " */" + NL + "  ADCGLOB001_DynamicDataType * const kDynamicDataPtr;";
  protected final String TEXT_2 = " " + NL + "/**" + NL + " * Boundary Value 0 for Limit Checking.\\n" + NL + " * Range:12 Bits" + NL + " */" + NL + "  " + NL + "  const uint16_t KGlobBoundary0;" + NL + " /**" + NL + "  * Boundary Value 1 for Limit Checking.\\n" + NL + "  * Range:12 Bits" + NL + "  */  " + NL + "  const uint16_t KGlobBoundary1;";
  protected final String TEXT_3 = "  " + NL + "  /**" + NL + "   * Divider Factor for the Analog Internal Clock\\n" + NL + "   * 0  :fADCI = fADC/2;\\n" + NL + "   * 1  :fADCI = fADC/2;\\n" + NL + "   * 2  :fADCI = fADC/3;\\n" + NL + "   * ...\\n" + NL + "   * 1F :fADCI= fADC/32;" + NL + "   */    " + NL + "  const uint8_t kAnalogClkDivider;" + NL + "  /**" + NL + "   * Divider Factor for the Arbiter Clock\\n" + NL + "   * 0 :fADCD = fADC;\\n" + NL + "   * 1 :fADCD = fADC/2;\\n" + NL + "   * 2 :fADCD = fADC/3;\\n" + NL + "   * 3 :fADCD = fADC/4;" + NL + "   */  " + NL + "  const uint8_t kArbiterClkDivider ;" + NL + "/**" + NL + " * Class 0 Sample Time Control for Standard Conversions\\n" + NL + " * Range:[4:0] Bits " + NL + " */  " + NL + "  const uint8_t kSampleTimeControlClass0;" + NL + "  /**" + NL + "   * Class 1 Sample Time Control for Standard Conversions\\n" + NL + "   * Range:[4:0] Bits " + NL + "   */      " + NL + "  const uint8_t kSampleTimeControlClass1 ;";
  protected final String TEXT_4 = "   " + NL + "  /**" + NL + "   * Class 0 Sample Time Control for EMUX Conversions\\n" + NL + "   * Range:[4:0] Bits " + NL + "   */    " + NL + "  const uint8_t kEMUXSampleTimeControlClass0;" + NL + "  /**" + NL + "   * Class 1 Sample Time Control for EMUX Conversions\\n" + NL + "   * Range:[4:0] Bits " + NL + "   */        " + NL + "  const uint8_t kEMUXSampleTimeControlClass1 ;";
  protected final String TEXT_5 = "  " + NL + "  /**" + NL + "   * Class 0 Conversion Mode for Standard Conversions\\n" + NL + "   * 0 :12-bit conversion\\n" + NL + "   * 1 :10-bit conversion\\n" + NL + "   * 2 :8-bit conversion\\n" + NL + "   * 5 :10-bit fast compare mode\\n" + NL + "   * 3,4,6,7 :Reserved" + NL + "   */  " + NL + "  const uint8_t kConversionModeClass0;" + NL + "    /**" + NL + "       * Class 1 Conversion Mode for Standard Conversions\\n" + NL + "       * 0 :12-bit conversion\\n" + NL + "       * 1 :10-bit conversion\\n" + NL + "       * 2 :8-bit conversion\\n" + NL + "       * 5 :10-bit fast compare mode\\n" + NL + "       * 3,4,6,7 :Reserved" + NL + "       */  " + NL + "    const uint8_t kConversionModeClass1;";
  protected final String TEXT_6 = NL + "  /**" + NL + "   * Class 0 Conversion Mode for EMUX Conversions\\n" + NL + "   * 0 :12-bit conversion\\n" + NL + "   * 1 :10-bit conversion\\n" + NL + "   * 2 :8-bit conversion\\n" + NL + "   * 5 :10-bit fast compare mode\\n" + NL + "   * 3,4,6,7 :Reserved" + NL + "   */   " + NL + "  const uint8_t kEMUXConversionModeClass0;" + NL + "  /**" + NL + "   *  Class 1 Conversion Mode for EMUX Conversions\\n" + NL + "   * 0 :12-bit conversion\\n" + NL + "   * 1 :10-bit conversion\\n" + NL + "   * 2 :8-bit conversion\\n" + NL + "   * 5 :10-bit fast compare mode\\n" + NL + "   * 3,4,6,7 :Reserved" + NL + "   */  " + NL + "  const uint8_t kEMUXConversionModeClass1;";
  protected final String TEXT_7 = "  " + NL + "  /**" + NL + "   * Variable to configure the Start-Up Calibration\\n" + NL + "   * 0: No action\\n" + NL + "   * 1: Initiate the start-up calibration phase" + NL + "   */  " + NL + "  const uint8_t keStartCalib;" + NL + "     " + NL + "}ADCGLOB001_HandleType;" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "/**" + NL + " * @ingroup ADCGLOB001_apidoc" + NL + " * @{" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + " **FUNCTION PROTOTYPES                                                        **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @brief This function will initialize VADC Global registers with user configured values." + NL + " * @return void" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode " + NL + " */" + NL + "void ADCGLOB001_Init(void);" + NL + "/**" + NL + " * @brief This function will de-initialize VADC Global registers." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     //Do something" + NL + "     ADCGLOB001_Deinit(); //Deinit function call." + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode " + NL + " */" + NL + "status_t ADCGLOB001_DeInit(const ADCGLOB001_HandleType * HandlePtr);" + NL + "/**" + NL + " * @brief This function will disable the control of the VADC module." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_CLKRequestDisable(&ADCGLOB001_Handle0); //called to disable the control of the module" + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_CLKRequestDisable(const ADCGLOB001_HandleType * HandlePtr);" + NL + "/**" + NL + " * @brief This function will enable the control of the VADC module." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_CLKRequestEnable(&ADCGLOB001_Handle0); //called to enable the control of the module" + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_CLKRequestEnable(const ADCGLOB001_HandleType * HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function will initiate the startup calibration phase." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_SetStartUpCalibration(&ADCGLOB001_Handle0); //Initiate the start-up calibration" + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_SetStartUpCalibration(const ADCGLOB001_HandleType *HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function will enable the sleep mode control." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_EnableSleepModeControl(&ADCGLOB001_Handle0); //Enables Sleep Mode Control" + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_EnableSleepModeControl(const ADCGLOB001_HandleType * HandlePtr);" + NL + "/**" + NL + " * @brief This function will disregard the sleep mode control." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + "* @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_DisregardSleepModeControl(&ADCGLOB001_Handle0); //called to disregards Sleep Mode Control" + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_DisregardSleepModeControl(const ADCGLOB001_HandleType * HandlePtr);" + NL + "/**" + NL + " * @brief This function will configure the class 0 conversion mode for standard conversions.\\n" + NL + " * ADCGLOB001_12BIT 12-bit conversion\\n" + NL + " * ADCGLOB001_10BIT 10-bit conversion\\n" + NL + " * ADCGLOB001_8BIT 8-bit conversion \\n" + NL + " * ADCGLOB001_10BITFAST 10-bit fast compare mode\\n" + NL + " * and remaining bits are reserved for future use." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @param[in] ConversionModeVal This is the enum type which need to be configured in the GLOBICLASS[0] register." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " *         ADCGLOB001_INVALID_PARAM_ERROR: If ConversionModeVal is not equal ADCGLOB001_12BIT,ADCGLOB001_10BIT,ADCGLOB001_8BIT and ADCGLOB001_10BITFAST" + NL + " * <BR>" + NL + " *" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_SetGlobClass0ConvMode(&ADCGLOB001_Handle0,ADCGLOB001_12BIT); //configure the class 0 conversion mode value to 10-bit" + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_SetGlobClass0ConvMode(const ADCGLOB001_HandleType * HandlePtr , ADCGLOB001_ConversionMode ConversionModeVal);" + NL + "" + NL + "/**" + NL + " * @brief This function will configure the class 0 Sample Time Control for Standard Conversions.\\n" + NL + " *  Sample time is the actual register bit field (STCS) value and it's range is from 0 to 31." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @param[in] SampleTime value which need to be configure in the GLOBICLASS[0] register." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " *         ADCGLOB001_INVALID_PARAM_ERROR: If SampleTime < 0 or SampleTime > 31" + NL + " * <BR>" + NL + " *" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     uint8_t stcsvalue=15;" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_SetGlobClass0SampleTime(&ADCGLOB001_Handle0,stcsvalue); //configure the class 0 Sample Time Control for Standard Conversions" + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_SetGlobClass0SampleTime(const ADCGLOB001_HandleType * HandlePtr, uint8_t SampleTime);";
  protected final String TEXT_8 = NL + "/**" + NL + " * @brief This function will configure the class 0 Sample Time Control for EMUX Conversions.\\n" + NL + " *  Sample time is the actual register bit field (STCS) value and it's range is from 0 to 31." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @param[in] SampleTime value which need to be configure in the GLOBICLASS[0] register." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " *         ADCGLOB001_INVALID_PARAM_ERROR: If SampleTime < 0 or SampleTime > 31" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     uint8_t stcevalue=15;" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_SetGlobClass0EmuxSampleTime(&ADCGLOB001_Handle0,stcevalue); //configure the class 0 Sample Time Control for EMUX Conversions." + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_SetGlobClass0EmuxSampleTime(const ADCGLOB001_HandleType * HandlePtr,uint8_t SampleTime);" + NL + "" + NL + "/**" + NL + " * @brief This function will configure the class 0 Conversion Mode for EMUX Conversions.\\n" + NL + " * ADCGLOB001_12BIT 12-bit conversion\\n" + NL + " * ADCGLOB001_10BIT 10-bit conversion\\n" + NL + " * ADCGLOB001_8BIT 8-bit conversion \\n" + NL + " * ADCGLOB001_10BITFAST 10-bit fast compare mode \\n" + NL + " * and remaining bits are reserved for future use." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @param[in] ConversionModeVal This is the enum type which need to be configure in the GLOBICLASS[0] register." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " *         ADCGLOB001_INVALID_PARAM_ERROR: If ConversionModeVal is not equal ADCGLOB001_12BIT,ADCGLOB001_10BIT,ADCGLOB001_8BIT and ADCGLOB001_10BITFAST" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_SetGlobClass0EmuxConvMode(&ADCGLOB001_Handle0,ADCGLOB001_10BIT); //configure the class 0 Conversion Mode for EMUX Conversions as 10 bits." + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_SetGlobClass0EmuxConvMode(const ADCGLOB001_HandleType * HandlePtr,ADCGLOB001_ConversionMode ConversionModeVal);";
  protected final String TEXT_9 = NL + "/**" + NL + " * @brief This function will configure the class 1 conversion mode for standard conversions.\\n" + NL + " * ADCGLOB001_12BIT 12-bit conversion\\n" + NL + " * ADCGLOB001_10BIT 10-bit conversion\\n" + NL + " * ADCGLOB001_8BIT 8-bit conversion \\n" + NL + " * ADCGLOB001_10BITFAST 10-bit fast compare mode \\n" + NL + " * and remaining bits are reserved for future use." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @param[in] ConversionModeVal This is the enum type which need to be configure in the GLOBICLASS[1] register." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " *         ADCGLOB001_INVALID_PARAM_ERROR: If ConversionModeVal is not equal ADCGLOB001_12BIT,ADCGLOB001_10BIT,ADCGLOB001_8BIT and ADCGLOB001_10BITFAST" + NL + " * <BR>" + NL + " *" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_SetGlobClass1ConvMode(&ADCGLOB001_Handle0,ADCGLOB001_8BIT); //configure the class 1 conversion mode value to 10-bit" + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_SetGlobClass1ConvMode(const ADCGLOB001_HandleType * HandlePtr , ADCGLOB001_ConversionMode ConversionModeVal);" + NL + "" + NL + "/**" + NL + " * @brief This function will configure the class 1 Sample Time Control for Standard Conversions.\\n" + NL + " *  Sample time is the actual register bit field (STCS) value and it's range is from 0 to 31." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @param[in] SampleTime value which need to be configure in the GLOBICLASS[1] register." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " *         ADCGLOB001_INVALID_PARAM_ERROR: If SampleTime < 0 or SampleTime > 31" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     uint8_t stcsvalue=15;" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_SetGlobClass1SampleTime(&ADCGLOB001_Handle0,stcsvalue); //configure the class 1 Sample Time Control for Standard Conversions" + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_SetGlobClass1SampleTime(const ADCGLOB001_HandleType * HandlePtr, uint8_t SampleTime);";
  protected final String TEXT_10 = NL + "/**" + NL + " * @brief This function will configure the class 1 Sample Time Control for EMUX Conversions.\\n" + NL + " *  Sample time is the actual register bit field (STCE) value and it's range is from 0 to 31." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @param[in] SampleTime value which need to be configure in the GLOBICLASS[1] register." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " *         ADCGLOB001_INVALID_PARAM_ERROR: If SampleTime < 0 or SampleTime > 31" + NL + " * <BR>" + NL + " *" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     uint8_t stcevalue=15;" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_SetGlobClass1EmuxSampleTime(&ADCGLOB001_Handle0,stcevalue); //configure the class 1 Sample Time Control for EMUX Conversions." + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_SetGlobClass1EmuxSampleTime(const ADCGLOB001_HandleType * HandlePtr,uint8_t SampleTime);" + NL + "" + NL + "/**" + NL + " * @brief This function configure the class 1 Conversion Mode for EMUX Conversions.\\n" + NL + " * ADCGLOB001_12BIT 12-bit conversion\\n" + NL + " * ADCGLOB001_10BIT 10-bit conversion\\n" + NL + " * ADCGLOB001_8BIT 8-bit conversion \\n" + NL + " * ADCGLOB001_10BITFAST 10-bit fast compare mode \\n" + NL + " * and remaining bits are reserved for future use." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @param[in] ConversionModeVal This is the enum type which need to be configure in the GLOBICLASS[1] register." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " *         ADCGLOB001_INVALID_PARAM_ERROR: If ConversionModeVal is not equal ADCGLOB001_12BIT,ADCGLOB001_10BIT,ADCGLOB001_8BIT and ADCGLOB001_10BITFAST" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_SetGlobClass1EmuxConvMode(&ADCGLOB001_Handle0,ADCGLOB001_10BITFAST); //configure the class 1 Conversion Mode for EMUX Conversions as 10 bits." + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_SetGlobClass1EmuxConvMode(const ADCGLOB001_HandleType * HandlePtr,ADCGLOB001_ConversionMode ConversionModeVal);";
  protected final String TEXT_11 = NL + "/**" + NL + " * @brief This function will give the status of Module Disable bit." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @param[out] StatusValue Its pointer to uint8_t which return the status value." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " * <BR>" + NL + " *" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     uint8_t variable=0;" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_GetDisableBitStatus(&ADCGLOB001_Handle0,&variable); //variable holds the status of Module Disable bit.." + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "" + NL + "status_t ADCGLOB001_GetDisableBitStatus(const ADCGLOB001_HandleType * HandlePtr, uint8_t *StatusValue);" + NL + "" + NL + "/**" + NL + " * @brief This function will give the VADC module Id Value." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @param[out] IDValue Its pointer to uint8_t which return the Id value." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " * <BR>" + NL + " *" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + "  * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     uint32_t IdValue=0;" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_GetIdValue(&ADCGLOB001_Handle0,&IdValue); //IdValue holds the ID Value." + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "" + NL + "status_t ADCGLOB001_GetIdValue(const ADCGLOB001_HandleType * HandlePtr, uint32_t *IDValue);";
  protected final String TEXT_12 = NL + NL + "/**" + NL + " * @brief This function will configure the group number to be used for converter diagnostics conversions." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @param[in] GroupValue Value which need to be configure in the GLOBTF register." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " *         ADCGLOB001_INVALID_PARAM_ERROR: if GroupValue > 15" + NL + " * <BR>" + NL + " *" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     uint8_t cdgrvalue=5;" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_GTFRConvtrDiagnoGrp(&ADCGLOB001_Handle0,cdgrvalue); //configure the group number to be used for converter diagnostics conversions." + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_GTFRConvtrDiagnoGrp(const ADCGLOB001_HandleType * HandlePtr, uint8_t GroupValue);" + NL + "" + NL + "/**" + NL + " * @brief This function will configure the Converter Diagnostics pull devices connected as selected" + NL + " * by bitfield CDSEL." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>        " + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_GTFRConvtrDiagnoEnable(&ADCGLOB001_Handle0); //configure the Converter Diagnostics pull devices enable bit." + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "" + NL + "status_t ADCGLOB001_GTFRConvtrDiagnoEnable(const ADCGLOB001_HandleType * HandlePtr);" + NL + "/**" + NL + " * @brief This function will configure the Converter Diagnostics Pull-Devices Select value." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @param[in] SelectValue Value which need to be configure in the GLOBTF register." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " *         ADCGLOB001_INVALID_PARAM_ERROR: if SelectValue > 3" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     uint8_t cdselvalue=1;" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_GTFRConvtrDiagnoPullDevicesSelect(&ADCGLOB001_Handle0,cdselvalue); //Connected to VAGND" + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "" + NL + "status_t ADCGLOB001_GTFRConvtrDiagnoPullDevicesSelect(const ADCGLOB001_HandleType * HandlePtr, uint8_t SelectValue);" + NL + "/**" + NL + " * @brief This function will configure the Pull-Down Diagnostics Enable register." + NL + " * @param[in] HandlePtr Handle of the ADCGLOB001 App" + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " * <BR>" + NL + " *" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_GTFRPullDwnDiagnoEnable(&ADCGLOB001_Handle0); //Enable the Pull-Down Diagnostics Enable register." + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "" + NL + "status_t ADCGLOB001_GTFRPullDwnDiagnoEnable(const ADCGLOB001_HandleType * HandlePtr);";
  protected final String TEXT_13 = NL + NL + "/**" + NL + " * @brief This function will initiate the startup calibration phase based on the GUI configurations." + NL + " * It is called after ADCGROUP001 App Init function." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     ADCGLOB001_StartUpCalibrationInit(); //Initiate the start-up calibration based on GUI configuration." + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_StartUpCalibrationInit(void);";
  protected final String TEXT_14 = " " + NL + "/**" + NL + " * @brief This function will do post calibrations using background request source." + NL + " * It is called before ADCGROUP001 App Init function." + NL + " * @return status_t <BR>" + NL + " *         DAVEApp_SUCCESS : If function is successful <BR>" + NL + " *         ADCGLOB001_OPER_NOT_ALLOWED: If function is called from the UNINITIALIZED state <BR>" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "status_t ADCGLOB001_SetStartUpCalibration(" + NL + "        const ADCGLOB001_HandleType *HandlePtr" + NL + ")" + NL + "{" + NL + "    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;" + NL + "" + NL + "    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)" + NL + "    {" + NL + "" + NL + "        SET_BIT( HandlePtr->kGlobalPtr->GLOBCFG, VADC_GLOBCFG_SUCAL_Pos);" + NL + "        " + NL + "        ADCGLOB001_PostCalibration();" + NL + "" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "" + NL + "    return Status;" + NL + "}" + NL + " * @endcode" + NL + " */" + NL + "status_t ADCGLOB001_PostCalibration(void);" + NL + "/**" + NL + " * @}" + NL + " */";
  protected final String TEXT_15 = NL + NL + "/** " + NL + " * @brief DisableWritetoVadcRegisters function is called to disable write to VADC registers, this function can" + NL + " * be called only if the user wants to disable writing to VADC registers. To enable writing to registers" + NL + " * EnableWritetoVadcRegisters() function needs to be called. " + NL + " * this function needs be called only after enabling the vadc module i.e.  CLR_BIT( ADCGLOB001_Handle0.kGlobalPtr->CLC, VADC_CLC_DISR_Pos);" + NL + " * @return" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + "" + NL + "  void ADCGLOB001_Init(void)" + NL + "  {" + NL + "  ." + NL + "  ." + NL + "  ." + NL + "    // Bring the module out of disabled state." + NL + "    CLR_BIT( ADCGLOB001_Handle0.kGlobalPtr->CLC, VADC_CLC_DISR_Pos);" + NL + "" + NL + "    EnableWritetoVadcRegisters();" + NL + "   ." + NL + "   ." + NL + "   . " + NL + "    DisableWritetoVadcRegisters();" + NL + "    " + NL + "   }" + NL + "    " + NL + " * @endcode" + NL + " */" + NL + "void DisableWritetoVadcRegisters(void);" + NL + "" + NL + "/**" + NL + " * @brief By default all VADC registers are writable." + NL + " * EnableWritetoVadcRegisters() function is called to write to registers, this function can be called" + NL + " * only if the VADC registers disabled for writing by calling the function DisableWritetoVadcRegisters()" + NL + " * @return none" + NL + " * <BR>" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " * @code" + NL + "   #include <DAVE3.h>" + NL + "   int main (void)" + NL + "   {" + NL + "     DAVE_Init();   //ADCGLOB001_Init is called within DAVE_Init()" + NL + "     " + NL + "     while(1);" + NL + "     return 0;" + NL + "   }" + NL + "   " + NL + "   void ADCGLOB001_Init(void)" + NL + "  {" + NL + "  ." + NL + "  ." + NL + "  ." + NL + "    // Bring the module out of disabled state." + NL + "    CLR_BIT( ADCGLOB001_Handle0.kGlobalPtr->CLC, VADC_CLC_DISR_Pos);" + NL + "" + NL + "    EnableWritetoVadcRegisters();" + NL + "   ." + NL + "   ." + NL + "   . " + NL + "    DisableWritetoVadcRegisters();" + NL + "    " + NL + "   }" + NL + " * @endcode" + NL + " */" + NL + "void EnableWritetoVadcRegisters(void);";
  protected final String TEXT_16 = NL + NL + "#include \"ADCGlob001_Conf.h\"" + NL + "" + NL + "#ifdef __cplusplus" + NL + "}" + NL + "#endif" + NL + "  " + NL + "#endif /* ADCGLOB_H_ */";

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
     int Is44Device = -1; 
     int Is42Device = -1; 
     int Is45Device = -1; 
     int Is11Device = -1; 
     int Is1xDevice = -1; 
     Is44Device = ((app.getSoftwareId().substring(0,2).compareTo("44")==0)?1:0); 
     Is42Device = ((app.getSoftwareId().substring(0,2).compareTo("42")==0)?1:0); 
     Is45Device = ((app.getSoftwareId().substring(0,2).compareTo("45")==0)?1:0); 
     Is11Device = ((app.getSoftwareId().substring(0,2).compareTo("11")==0)?1:0); 
     Is1xDevice = ((app.getSoftwareId().substring(0,1).compareTo("1")==0)?1:0); 
    stringBuffer.append(TEXT_1);
    if (Is11Device!=1)	{
    stringBuffer.append(TEXT_2);
     } 
    stringBuffer.append(TEXT_3);
    if (Is11Device!=1)	{
    stringBuffer.append(TEXT_4);
     } 
    stringBuffer.append(TEXT_5);
    if (Is11Device!=1)	{
    stringBuffer.append(TEXT_6);
     } 
    stringBuffer.append(TEXT_7);
     if(Is11Device != 1) {
    stringBuffer.append(TEXT_8);
    }
    stringBuffer.append(TEXT_9);
     if(Is11Device != 1) {
    stringBuffer.append(TEXT_10);
    }
    stringBuffer.append(TEXT_11);
    if (Is45Device==1 || Is44Device==1 || Is42Device==1 )
    	{
    stringBuffer.append(TEXT_12);
     } 
    stringBuffer.append(TEXT_13);
    if ((Is1xDevice == 1) && (Is11Device != 1))	{
    stringBuffer.append(TEXT_14);
    }
    if (Is45Device!=1 && Is44Device!=1 && Is42Device!=1 )
    	{
    stringBuffer.append(TEXT_15);
     } 
    stringBuffer.append(TEXT_16);
    return stringBuffer.toString();
  }
}
