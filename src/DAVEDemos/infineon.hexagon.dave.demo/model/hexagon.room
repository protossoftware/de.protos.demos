RoomModel hexagon {

	import room.basic.types.* from "Types.room"

	import room.basic.service.timing.* from "TimingService.room"

	import DaveInterface.* from "DaveInterface.room"

	LogicalSystem hexagon {
		SubSystemRef main: MainSubSystem
	}

	SubSystemClass MainSubSystem {
		ActorRef appl: Application
		ActorRef timingService: ATimingService
		LayerConnection ref appl satisfied_by timingService.timer
		LogicalThread defaultThread
	}

	ActorClass Application {
		Structure {
			conjugated Port blinkyPort: PBlinkyControl
			conjugated Port buttonControlPort: PButtonControlProtocoll
			conjugated Port buttonPort: PButtonProtocoll
			conjugated Port adcControlPort: PAdcControlProtocoll
			ActorRef blinky: ABlinky
			ActorRef button: AButtonController
			ActorRef display: ADisplay
			ActorRef adc: AAdc
			ActorRef i2c: AI2CController
			ActorRef uart: AUartController
			Binding blinkyPort and blinky.controlPort
			Binding buttonControlPort and button.controlPort
			Binding buttonPort and button.ioPort
			Binding adcControlPort and adc.control
			Binding adc.payload and i2c.payload
			Binding adc.payload and display.control
			Binding adc.payload and uart.p0
		}
		Behavior {
			StateMachine {
				Transition init: initial -> running {
					action {
						"buttonControlPort.setInstance(2);"
						"adcControlPort.setInstance(0);"
					}
				}
				Transition tr1: running -> halted {
					triggers {
						<pressed: buttonPort>
					}
					action {
						"blinkyPort.start();"
					}
				}
				Transition tr0: halted -> running {
					triggers {
						<pressed: buttonPort>
					}
					action {
						"blinkyPort.stop();"
					}
				}
				State running
				State halted
			}
		}
	}

	ActorClass AButtonController {
		Interface {
			Port ioPort: PButtonProtocoll
			Port controlPort: PButtonControlProtocoll
		}
		Structure {
			external Port ioPort
			external Port controlPort
			conjugated Port hwPin: PIO004
			SAP timer: PTimer
			Attribute pinState: uint8
		}
		Behavior {
			StateMachine {
				Transition init: initial -> waitForInstance
				Transition tr0: waitForInstance -> polling {
					triggers {
						<setInstance: controlPort>
					}
					action {
						"hwPin.setInstance(data);"
						"timer.startTimer(50);"
					}
				}
				State waitForInstance
				State polling {
					subgraph {
						Transition init: initial -> notPressed
						Transition tr0: notPressed -> cp cp1 {
							triggers {
								<timeout: timer>
							}
							action {
								"hwPin.readPin(&pinState);"
							}
						}
						Transition tr1: pressed -> cp cp0 {
							triggers {
								<timeout: timer>
							}
							action {
								"hwPin.readPin(&pinState);"
							}
						}
						Transition tr2: cp cp0 -> notPressed {
							action {
								"ioPort.released();"
							}
						}
						Transition tr3: cp cp0 -> pressed {
							cond {
								"pinState == 0"
							}
						}
						Transition tr4: cp cp1 -> pressed {
							action {
								"ioPort.pressed();"
							}
						}
						Transition tr5: cp cp1 -> notPressed {
							cond {
								"pinState == 1"
							}
						}
						ChoicePoint cp0
						ChoicePoint cp1
						State notPressed
						State pressed
					}
				}
			}
		}
	}

	ActorClass ADisplay {
		Interface {
			conjugated Port control: PAdcProtocoll
		}
		Structure {
			usercode1 {
				"#include <GUI.h>"
			} usercode3 {
				"/*******************************************************************************"
				"** EXTERN Declarations                                                       **"
				"******************************************************************************/"
				"extern const GUI_BITMAP bmIFX_LOGO;"
				"extern const GUI_BITMAP bmXMC_test;"
				"extern const GUI_BITMAP bmeTriceLogo;"
				"extern const GUI_BITMAP bmprotosLogo;"
			}
			external Port control
			conjugated Port gui: PGUI
			SAP timer: PTimer
			SAP timerAdc: PTimer
			Attribute str: DGuiString
			Attribute bmp: DGuiBitmap
			Attribute showTime: int32
			Attribute adcVal: uint32
		}
		Behavior {
			StateMachine {
				Transition init: initial -> tp0 of playShow {
					action {
						"gui.init();"
						""
						"gui.init();"
						""
						"gui.setBkColor(GUI_WHITE);"
						"gui.clear();"
						""
						"gui.setColor(GUI_BLUE);"
						"gui.setFont(&GUI_Font24B_1);"
					}
				}
				Transition tr0: playShow -> tp0 of showADCVals {
					triggers {
						<newVal: control>
					}
					action {
						"timer.kill();"
						"gui.clear();"
						"timerAdc.startTimeout(1000);"
						"adcVal=data;"
					}
				}
				Transition tr1: showADCVals -> playShow {
					triggers {
						<timeout: timerAdc>
					}
					action {
						"timer.startTimer(showTime);"
					}
				}
				State playShow {
					subgraph {
						Transition tr0: my tp0 -> dispProtos {
							action {
								"showTime=1000;"
								"timer.startTimeout(showTime);"
							}
						}
						Transition tr1: dispProtos -> dispAnd {
							triggers {
								<timeout: timer>
							}
							action {
								"timer.startTimeout(showTime);"
							}
						}
						Transition tr2: dispAnd -> dispInfi {
							triggers {
								<timeout: timer>
							}
							action {
								"timer.startTimeout(showTime);"
							}
						}
						Transition tr3: dispInfi -> dispPresents {
							triggers {
								<timeout: timer>
							}
							action {
								"timer.startTimeout(showTime);"
							}
						}
						Transition tr4: dispPresents -> dispEtrice {
							triggers {
								<timeout: timer>
							}
							action {
								"timer.startTimeout(showTime);"
							}
						}
						Transition tr5: dispEtrice -> dispOn {
							triggers {
								<timeout: timer>
							}
							action {
								"timer.startTimeout(showTime);"
							}
						}
						Transition tr6: dispOn -> dispXMC {
							triggers {
								<timeout: timer>
							}
							action {
								"timer.startTimeout(showTime);"
							}
						}
						Transition tr7: dispXMC -> dispProtos {
							triggers {
								<timeout: timer>
							}
							action {
								"timer.startTimeout(showTime);"
							}
						}
						Transition init: initial -> dispProtos
						EntryPoint tp0
						State dispProtos {
							entry {
								"gui.clear();"
								"bmp.bitmap = &bmprotosLogo;"
								"bmp.xPos = 5;"
								"bmp.yPos = 20;"
								""
								"gui.drawBitmap(&bmp);"
							}
						}
						State dispAnd {
							entry {
								"gui.clear();"
								"str.s=\"and\";"
								"str.xPos=80;"
								"str.yPos=50;"
								""
								"gui.dispStringHCenterAt(&str);"
							}
						}
						State dispInfi {
							entry {
								"gui.clear();"
								"bmp.bitmap = &bmIFX_LOGO;"
								"bmp.xPos = 5;"
								"bmp.yPos = 32;"
								""
								"gui.drawBitmap(&bmp);"
							}
						}
						State dispPresents {
							entry {
								"gui.clear();"
								"str.s=\"proudly\";"
								"str.xPos=80;"
								"str.yPos=30;"
								"gui.dispStringHCenterAt(&str);"
								""
								"str.s=\"presents...\";"
								"str.xPos=80;"
								"str.yPos=60;"
								"gui.dispStringHCenterAt(&str);"
							}
						}
						State dispEtrice {
							entry {
								"gui.clear();"
								"bmp.bitmap = &bmeTriceLogo;"
								"bmp.xPos = 25;"
								"bmp.yPos = 10;"
								""
								"gui.drawBitmap(&bmp);"
							}
						}
						State dispOn {
							entry {
								"gui.clear();"
								"str.s=\"on\";"
								"str.xPos=80;"
								"str.yPos=50;"
								""
								"gui.dispStringHCenterAt(&str);"
							}
						}
						State dispXMC {
							entry {
								"gui.clear();"
								"bmp.bitmap = &bmXMC_test;"
								"bmp.xPos = 0;"
								"bmp.yPos = 0;"
								""
								"gui.drawBitmap(&bmp);"
							}
						}
					}
				}
				State showADCVals {
					subgraph {
						Transition tr0: my tp0 -> state0
						Transition tr1: state0 -> state0 {
							triggers {
								<newVal: control>
							}
							action {
								"adcVal=data;"
								"timerAdc.kill();"
								"timerAdc.startTimeout(1000);"
							}
						}
						EntryPoint tp0
						State state0 {
							entry {
								"uint8 buffer[20];"
								""
								"sprintf(&buffer,\"%04i\",adcVal/10);"
								"str.s=&buffer;"
								"str.xPos=70;"
								"str.yPos=60;"
								""
								"gui.dispStringHCenterAt(&str);"
							}
						}
					}
				}
			}
		}
	}

	ActorClass AI2CController {
		Interface {
			conjugated Port payload: PAdcProtocoll
		}
		Structure {
			external Port payload
			conjugated Port i2c: PI2C001
		}
		Behavior {
			StateMachine {
				Transition init: initial -> state0 {
					action {
						"i2c.setInstance(0);"
						"i2c.setI2CAddr(0x9A );"
						"i2c.init();"
					}
				}
				Transition tr0: state0 -> state0 {
					triggers {
						<newVal: payload>
					}
					action {
						"uint32 h;"
						""
						""
						"h=(data+256)/512;"
						"switch(h){"
						"case 0:"
						"\ti2c.writeData(0xff);"
						"\tbreak;"
						"case 1:"
						"\ti2c.writeData(0xfe);"
						"\tbreak;"
						"case 2:"
						"\ti2c.writeData(0xfc);"
						"\tbreak;"
						"case 3:"
						"\ti2c.writeData(0xf8);"
						"\tbreak;"
						"case 4:"
						"\ti2c.writeData(0xf0);"
						"\tbreak;"
						"case 5:"
						"\ti2c.writeData(0xe0);"
						"\tbreak;"
						"case 6:"
						"\ti2c.writeData(0xc0);"
						"\tbreak;"
						"case 7:"
						"\ti2c.writeData(0x80);"
						"\tbreak;"
						"case 8:"
						"\ti2c.writeData(0x00);"
						"\tbreak;"
						"}"
					}
				}
				State state0
			}
		}
	}

	ActorClass ABlinky {
		Interface {
			Port controlPort: PBlinkyControl
		}
		Structure {
			external Port controlPort
			conjugated Port LED1: PIO004
			SAP timer: PTimer
			Attribute counter: int32 = "0"
			Attribute test: boolean = "ET_TRUE"
		}
		Behavior {
			StateMachine {
				Transition init: initial -> tp1 of blinking {
					action {
						"LED1.setInstance(1);"
					}
				}
				Transition tr0: blinking -> stop {
					triggers {
						<stop: controlPort>
					}
					action {
						"LED1.setPin();"
					}
				}
				Transition tr1: stop -> tp0 of blinking {
					triggers {
						<start: controlPort>
					}
				}
				State stop
				State blinking {
					subgraph {
						Transition tr0: my tp0 -> on
						Transition tr1: on -> off {
							triggers {
								<timeout: timer>
							}
							action {
								"counter++;test=ET_TRUE;"
							}
						}
						Transition tr2: off -> on {
							triggers {
								<timeout: timer>
							}
							action {
								"counter++;"
							}
						}
						Transition tr3: my tp1 -> on
						EntryPoint tp0
						EntryPoint tp1
						State on {
							entry {
								"timer.startTimeout(500);"
								"LED1.resetPin();"
							}
						}
						State off {
							entry {
								"timer.startTimeout(500);"
								"LED1.setPin();"
							}
						}
					}
				}
			}
		}
	}

	ActorClass AAdc {
		Interface {
			Port control: PAdcControlProtocoll
			Port payload [3]: PAdcProtocoll
		}
		Structure {
			external Port control
			external Port payload
			conjugated Port adc: PADC001
			SAP timer: PTimer
			Attribute lastVal: int32
			Attribute currentVal: int32
		}
		Behavior {
			StateMachine {
				Transition init: initial -> waitForInstance
				Transition tr1: state0 -> cp cp0 {
					triggers {
						<timeout: timer>
					}
					action {
						"timer.startTimeout(50);"
						"adc.getResult(&currentVal);"
					}
				}
				Transition tr2: cp cp0 -> state0
				Transition changed: cp cp0 -> state0 {
					cond {
						"((currentVal > (lastVal + 10)) || (currentVal < (lastVal- 10)))"
					}
					action {
						"lastVal=currentVal;"
						"payload.newVal(currentVal);"
					}
				}
				Transition tr4: waitForInstance -> state0 {
					triggers {
						<setInstance: control>
					}
					action {
						"adc.setInstance(data);"
						"adc.generateLoadEvent();"
						"timer.startTimeout(50);"
					}
				}
				ChoicePoint cp0
				State state0
				State waitForInstance
			}
		}
	}

	ActorClass AUartController {
		Interface {
			conjugated Port p0: PAdcProtocoll
		}
		Structure {
			external Port p0
			conjugated Port uart: PUART001
		}
		Behavior {
			StateMachine {
				Transition init: initial -> state0 {
					action {
						"uart.setInstance(0);"
					}
				}
				Transition tr0: state0 -> state0 {
					triggers {
						<newVal: p0>
					}
					action {
						"uint8 buffer[20];"
						"sprintf(&buffer,\"%04i\\n\",data/10);\t\t\t\t\t\t\t"
						""
						"uart.writeDataBytes(buffer, 5);"
					}
				}
				State state0
			}
		}
	}

	ProtocolClass PButtonControlProtocoll {
		incoming {
			Message setInstance(data: int32)
		}
	}

	ProtocolClass PButtonProtocoll {
		incoming {
			Message setInstance(data: int32)
		}
		outgoing {
			Message pressed()
			Message released()
			Message longPressed()
		}
	}

	ProtocolClass PBlinkyControl {
		incoming {
			Message start()
			Message stop()
		}
	}

	ProtocolClass PAdcControlProtocoll {
		incoming {
			Message setInstance(data: int32)
			Message start()
			Message stop()
		}
	}

	ProtocolClass PAdcProtocoll {
		outgoing {
			Message newVal(data: int32)
		}
	}

}