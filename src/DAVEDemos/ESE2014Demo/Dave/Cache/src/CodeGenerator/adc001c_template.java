package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class adc001c_template
{
  protected static String nl;
  public static synchronized adc001c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    adc001c_template result = new adc001c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/*CODE_BLOCK_BEGIN[ADC001.c]*/" + NL + "" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2013, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without**" + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR   : DAVE App Developer                                              **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Jan 29, 2014                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Author(s) Identity                                    **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** CM           DAVE App Developer                                            **" + NL + "** SSAM         Sridhar Sampath                                               **" + NL + "** ---------------------------------------------------------------------------**" + NL + "" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/**" + NL + " * @file ADC001.c" + NL + " *" + NL + " * @brief This file contains ADC001 App API definitions" + NL + " *" + NL + " * Change History:" + NL + " *  Date       version       Details" + NL + " * 16-Dec-2012   1.0.4    Initial code added for XMC1000" + NL + " * 06-Mar-2013   1.0.6    App version changed for XMC1000 and XMC4400/XMC4200" + NL + " * 24-Apr-2013   1.0.8    Ported to XMC4500 step AB and" + NL + " *                        Source Result selection Feature added" + NL + " * 11-Jun-2013   1.0.10   1. In channel selection page Group C and Group D check" + NL + " *                        boxes made invisible for XMC1200/1300/4200 devices." + NL + " *                        2. In the Header comment section device name changed" + NL + " *                           to XMC1000." + NL + " *                        3. Tooltip for the Group channel selection is modified" + NL + " *                        4. New api ADC001_GetFastResult() implemented." + NL + " *                        5. Source Result register selection feature disabled" + NL + " *                           due to header file update not available." + NL + " * 27-Jun-2013   1.0.12   Source Result register selection feature removed to" + NL + " *                        simplify the app." + NL + " * 27-Sep-2013   1.0.16   Typos in API Documentation & .h comments is corrected." + NL + " * 29-Jan-2014   1.0.18   Error codes are added in various functions," + NL + " *                        that can be logged with DBG002 App." + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + " ** INCLUDE FILES                                                             **" + NL + " ******************************************************************************/" + NL + "#include <DAVE3.h>" + NL;
  protected final String TEXT_2 = NL;
  protected final String TEXT_3 = NL + "/*****************************************************************************" + NL + "              DUMMY DEFINTIONS OF DEBUG LOG MACROS" + NL + "*****************************************************************************/" + NL + "/*These definitions are included here to avoid compilation errors," + NL + " since the DBG002 app is not part of the project. All the macros are defined" + NL + " as empty*/" + NL + "#ifndef _DBG002_H_" + NL + "" + NL + "#define DBG002_RegisterCallBack(A,B,C)" + NL + "#define DBG002_I(e)" + NL + "#define DBG002_IG(e,g)" + NL + "#define DBG002_IH(e,h)" + NL + "#define DBG002_IP(e,p)" + NL + "#define DBG002_IGH(e,g,h)" + NL + "#define DBG002_IGP(e,g,p)" + NL + "#define DBG002_IHP(e,h,p)" + NL + "#define DBG002_IGHP(e,g,h,p)" + NL + "#define DBG002_N(e)" + NL + "#define DBG002_NG(e,g)" + NL + "#define DBG002_NH(e,h)" + NL + "#define DBG002_NP(e,p)" + NL + "#define DBG002_NGH(e,g,h)" + NL + "#define DBG002_NGP(e,g,p)" + NL + "#define DBG002_NHP(e,h,p)" + NL + "#define DBG002_NGHP(e,g,h,p)" + NL + "#define DBG002_ID(e)" + NL + "#define DBG002_IS(e)" + NL + "#define DBG002_ISG(e,g)" + NL + "#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_ERROR(groupid,messageid,length,value)" + NL + "#define DBG002_WARNING(groupid,messageid,length,value)" + NL + "#define DBG002_INFO(groupid,messageid,length,value)" + NL + "#define DBG002_TRACE(groupid,messageid,length,value)" + NL + "#define DBG002_FUNCTION_ENTRY(GID, Status)" + NL + "#define DBG002_FUNCTION_EXIT(GID, Status)" + NL + "" + NL + "#define DBG002_MESSAGEID_LITERAL" + NL + "" + NL + "#endif/* End of defintions of dummy Debug Log macros*/";
  protected final String TEXT_4 = NL + NL + "/*******************************************************************************" + NL + "**                      Private Macro Definitions                             **" + NL + "*******************************************************************************/" + NL + "#define APP_GID DBG002_GID_ADC001" + NL + "" + NL + "/**" + NL + " * @cond INTERNAL_DOCS" + NL + " */" + NL + "/*******************************************************************************" + NL + "**                      Private Type Definitions                              **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Private Function Declarations:" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @brief This function initialises  the app." + NL + " *" + NL + " * @param [in] HandlePtr pointer to the Instance variable<BR>" + NL + " *" + NL + " * @return  NOne <BR>" + NL + " *" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " */" + NL + "" + NL + "void ADC001_lInit(const ADC001_HandleType *HandlePtr );" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Constant Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Function like macro definitions                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Public Function Definitions                           **" + NL + "*******************************************************************************/";
  protected final String TEXT_5 = NL + NL + NL + "/** This function initializes the app */" + NL + "void ADC001_Init(void)" + NL + "{" + NL + "  /*Initialize the global app */" + NL + "  ADCGLOB001_Init();";
  protected final String TEXT_6 = NL + "  ADC001_lInit(&ADC001_Handle0);";
  protected final String TEXT_7 = NL + "}" + NL + "" + NL + "/*" + NL + " * This Function initializes the ADC001 App." + NL + " */" + NL + "void ADC001_lInit(const ADC001_HandleType *HandlePtr )" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  uint8_t GroupNo;" + NL + "  uint8_t ChNo;" + NL + "  uint8_t ChIdx;" + NL + "  uint8_t GroupIdx;" + NL + "" + NL + "  /*Pointer to the VADC Structure */";
  protected final String TEXT_8 = NL + "  VADC_G_TypeDef *VADCGroupPtr[4];";
  protected final String TEXT_9 = NL + "  VADC_G_TypeDef *VADCGroupPtr[2];";
  protected final String TEXT_10 = NL + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;" + NL + "  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;";
  protected final String TEXT_11 = NL + "  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;" + NL + "  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;";
  protected final String TEXT_12 = NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if((HandlePtr->DynamicHandlePtr->State == ADC001_UNINITIALIZED))" + NL + "  {" + NL + "" + NL + "    for(ChIdx = (uint8_t)0; ChIdx < (uint8_t)HandlePtr->kChannels; ChIdx++)" + NL + "    {" + NL + "      GroupNo = ADC001_ChannelHandlePtr[ChIdx]->kGroupNo;" + NL + "      ChNo = ADC001_ChannelHandlePtr[ChIdx]->kChannelNo;" + NL + "      /* Input class */" + NL + "      WR_REG( VADCGroupPtr[GroupNo]->CHCTR[ChNo]," + NL + "        VADC_G_CHCTR_ICLSEL_Msk," + NL + "        VADC_G_CHCTR_ICLSEL_Pos," + NL + "        (uint32_t)HandlePtr->kIpClassSel" + NL + "       );" + NL + "" + NL + "      /* Store result in global register */" + NL + "      WR_REG( VADCGroupPtr[GroupNo]->CHCTR[ChNo]," + NL + "              VADC_G_CHCTR_RESTBS_Msk," + NL + "              VADC_G_CHCTR_RESTBS_Pos," + NL + "              (uint32_t)1" + NL + "             );" + NL + "" + NL + "      /*Result Alignment */" + NL + "      WR_REG( VADCGroupPtr[GroupNo]->CHCTR[ChNo]," + NL + "              VADC_G_CHCTR_RESPOS_Msk," + NL + "              VADC_G_CHCTR_RESPOS_Pos," + NL + "              (uint32_t)HandlePtr->kResultControl" + NL + "             );" + NL + "    }" + NL + "" + NL + "    /* Wait for read mode */" + NL + "    WR_REG( VADCGlobalPtr->GLOBRCR," + NL + "            VADC_GLOBRCR_WFR_Msk," + NL + "            VADC_GLOBRCR_WFR_Pos," + NL + "            (uint32_t)HandlePtr->kResultReadMode" + NL + "           );" + NL + "" + NL + "    /* Result event service request  */" + NL + "    WR_REG( VADCGlobalPtr->GLOBRCR," + NL + "            VADC_GLOBRCR_SRGEN_Msk," + NL + "            VADC_GLOBRCR_SRGEN_Pos," + NL + "            (uint32_t)HandlePtr->kResultEvtEnable" + NL + "           );" + NL + "" + NL + "    /* Select the input channels sequence */" + NL + "    VADCGlobalPtr->BRSSEL[0] =  HandlePtr->kGroup0ChSelect;" + NL + "    VADCGlobalPtr->BRSSEL[1] =  HandlePtr->kGroup1ChSelect;";
  protected final String TEXT_13 = NL + "    VADCGlobalPtr->BRSSEL[2] =  HandlePtr->kGroup2ChSelect;" + NL + "    VADCGlobalPtr->BRSSEL[3] =  HandlePtr->kGroup3ChSelect;";
  protected final String TEXT_14 = NL + NL + "    /*" + NL + "     * Enable XTWC Bitfield so that XTMODE and XTSEL can be written" + NL + "     * Selects trigger mode ." + NL + "     */" + NL + "    VADCGlobalPtr->BRSCTRL |= (uint32_t)(((uint32_t)1 << VADC_BRSCTRL_XTWC_Pos)    |  \\" + NL + "                      ((uint32_t)HandlePtr->kTriggerMode << VADC_BRSCTRL_XTMODE_Pos));" + NL + "    /*" + NL + "     * Selects the gating mode and enables trigger mode." + NL + "     * AutoScan enable or disable" + NL + "     * Source interrupt enable or disable" + NL + "     */" + NL + "    VADCGlobalPtr->BRSMR |=(uint32_t)(((uint32_t)HandlePtr->kTriggerEn            \\" + NL + "                                                      << VADC_BRSMR_ENTR_Pos) |   \\" + NL + "                                    ((uint32_t)HandlePtr->kGatingMode             \\" + NL + "                                                      << VADC_BRSMR_ENGT_Pos) |   \\" + NL + "                                    ((uint32_t)HandlePtr->kAutoScan               \\" + NL + "                                                      << VADC_BRSMR_SCAN_Pos) |   \\" + NL + "                                    ((uint32_t)HandlePtr->kResourceEvtEnable      \\" + NL + "                                                      << VADC_BRSMR_ENSI_Pos));" + NL + "" + NL + "    /*" + NL + "     * Enable Arbitration slot." + NL + "     * Select conversion start mode for request source." + NL + "     * Sets the priority of the background request source." + NL + "     */" + NL + "    for(GroupIdx = (uint8_t)0; GroupIdx < (uint8_t)ADC001_MAX_ADC_GROUP; GroupIdx++)" + NL + "    {" + NL + "      if(HandlePtr->kActiveGroups[GroupIdx] == (uint8_t)1)" + NL + "      {" + NL + "        VADCGroupPtr[GroupIdx]->ARBPR |= (uint32_t)(((uint32_t)HandlePtr->kAsenEnable <<  \\" + NL + "                                                         VADC_G_ARBPR_ASEN2_Pos) |        \\" + NL + "                                          ((uint32_t)HandlePtr->kStartmode   <<           \\" + NL + "                                                         VADC_G_ARBPR_CSM2_Pos)  |        \\" + NL + "                                          ((uint32_t)HandlePtr->kPriority    <<           \\" + NL + "                                                         VADC_G_ARBPR_PRIO2_Pos));" + NL + "      }" + NL + "    }" + NL + "" + NL + "    /* change the state to the Initialized */" + NL + "    HandlePtr->DynamicHandlePtr->State = ADC001_INITIALIZED;" + NL + "    Status &= (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " * This function resets the App." + NL + " */" + NL + "status_t ADC001_Deinit(const ADC001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint8_t GroupNo;" + NL + "  uint8_t ChNo;" + NL + "  uint8_t ChIdx;" + NL + "  uint8_t GroupIdx;" + NL + "" + NL + "  /*Pointer to the VADC Structure */";
  protected final String TEXT_15 = NL + "  VADC_G_TypeDef *VADCGroupPtr[4];";
  protected final String TEXT_16 = NL + "  VADC_G_TypeDef *VADCGroupPtr[2];";
  protected final String TEXT_17 = NL + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;" + NL + "  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;";
  protected final String TEXT_18 = NL + "  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;" + NL + "  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;";
  protected final String TEXT_19 = NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if((HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED))" + NL + "  {" + NL + "" + NL + "    for(ChIdx = (uint8_t)0; ChIdx < (uint8_t)HandlePtr->kChannels; ChIdx++)" + NL + "    {" + NL + "      GroupNo = (uint8_t )ADC001_ChannelHandlePtr[ChIdx]->kGroupNo;" + NL + "      ChNo = (uint8_t )ADC001_ChannelHandlePtr[ChIdx]->kChannelNo;" + NL + "      VADCGroupPtr[GroupNo]->CHCTR[ChNo] = (uint32_t )0;" + NL + "    }" + NL + "" + NL + "    VADCGlobalPtr->GLOBRCR = (uint32_t )0;" + NL + "" + NL + "    /* Select the input channels sequence */" + NL + "    VADCGlobalPtr->BRSSEL[0] =  (uint32_t )0;" + NL + "    VADCGlobalPtr->BRSSEL[1] =  (uint32_t )0;";
  protected final String TEXT_20 = NL + "    VADCGlobalPtr->BRSSEL[2] =  (uint32_t )0;" + NL + "    VADCGlobalPtr->BRSSEL[3] =  (uint32_t )0;";
  protected final String TEXT_21 = NL + "    VADCGlobalPtr->BRSCTRL = (uint32_t )0x00808000;" + NL + "" + NL + "    VADCGlobalPtr->BRSMR = (uint32_t )0;" + NL + "" + NL + "    /*" + NL + "     * Enable Arbitration slot." + NL + "     * Select conversion start mode for request source." + NL + "     * Sets the priority of the background request source." + NL + "     */" + NL + "    for(GroupIdx = (uint8_t )0; GroupIdx < (uint8_t )ADC001_MAX_ADC_GROUP; GroupIdx++)" + NL + "    {" + NL + "      if(HandlePtr->kActiveGroups[GroupIdx] == (uint8_t)1)" + NL + "      {" + NL + "        VADCGroupPtr[GroupIdx]->ARBPR = (uint32_t )0;" + NL + "      }" + NL + "    }" + NL + "" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    HandlePtr->DynamicHandlePtr->State = ADC001_UNINITIALIZED;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function selects the input class for the channel." + NL + " */" + NL + "status_t ADC001_SelectInputClass(const ADC001_HandleType* HandlePtr," + NL + "                                                  ADC001_GlobalInPutClass Class)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint8_t GroupNo;" + NL + "  uint8_t ChNo;" + NL + "  uint8_t ChIdx;" + NL + "" + NL + "  /*Pointer to the VADC Structure */";
  protected final String TEXT_22 = NL + "  VADC_G_TypeDef *VADCGroupPtr[4];";
  protected final String TEXT_23 = NL + "  VADC_G_TypeDef *VADCGroupPtr[2];";
  protected final String TEXT_24 = NL + NL + "  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;" + NL + "  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;";
  protected final String TEXT_25 = NL + "  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;" + NL + "  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;";
  protected final String TEXT_26 = NL + "  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if((Class == ADC001_GLOBAL_CLASS0) || (Class == ADC001_GLOBAL_CLASS1))" + NL + "    {" + NL + "      for(ChIdx = (uint8_t)0; ChIdx < (uint8_t)HandlePtr->kChannels; ChIdx++)" + NL + "      {" + NL + "        GroupNo = ADC001_ChannelHandlePtr[ChIdx]->kGroupNo;" + NL + "        ChNo = ADC001_ChannelHandlePtr[ChIdx]->kChannelNo;" + NL + "" + NL + "        /* Input class */" + NL + "        WR_REG( VADCGroupPtr[GroupNo]->CHCTR[ChNo]," + NL + "          VADC_G_CHCTR_ICLSEL_Msk," + NL + "          VADC_G_CHCTR_ICLSEL_Pos," + NL + "          (uint32_t)Class" + NL + "         );" + NL + "      }" + NL + "      Status = (uint8_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function enables the service request after result event." + NL + " */" + NL + "status_t ADC001_EnableResultEvt(const ADC001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)" + NL + "  {" + NL + "    /* Enable Result event service request  */" + NL + "    SET_BIT( VADCGlobalPtr->GLOBRCR, VADC_GLOBRCR_SRGEN_Pos);" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function disables the service request after result event." + NL + " */" + NL + "status_t ADC001_DisableResultEvt(const ADC001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)" + NL + "  {" + NL + "    /* Disables Result event service request  */" + NL + "    CLR_BIT( VADCGlobalPtr->GLOBRCR, VADC_GLOBRCR_SRGEN_Pos);" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function returns the result of the normal mode ADC conversion." + NL + " */" + NL + "status_t ADC001_GetResult(const ADC001_HandleType* HandlePtr," + NL + "                                            ADC001_ResultHandleType* ResultPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint32_t ADCResult;" + NL + "" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(ResultPtr != NULL)" + NL + "    {" + NL + "      ADCResult = VADCGlobalPtr->GLOBRES;" + NL + "      /* If valid flag is set */" + NL + "      if(((ADCResult & VADC_GLOBRES_VF_Msk) >> VADC_GLOBRES_VF_Pos) == (uint32_t)1)" + NL + "      {" + NL + "          ResultPtr->GroupNo = (uint8_t)((ADCResult & VADC_GLOBRES_GNR_Msk) >> VADC_GLOBRES_GNR_Pos);" + NL + "          ResultPtr->ChannelNo = (uint8_t)((ADCResult & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Pos);" + NL + "          ResultPtr->Result = (uint16_t)(ADCResult & VADC_GLOBRES_RESULT_Msk);" + NL + "          Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "      /* If data is old, then send error as invalid data */" + NL + "      else" + NL + "      {" + NL + "        Status = (uint32_t)ADC001_INVALID_RESULT;" + NL + "        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function returns the result of the normal mode ADC conversion without checking the valid bitfield." + NL + " */" + NL + "uint16_t ADC001_GetFastResult(const ADC001_HandleType* HandlePtr)" + NL + "{" + NL + "" + NL + "    /* Pointer to the VADC Kernel Structure */" + NL + "    VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "     VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "    return (uint16_t)(VADCGlobalPtr->GLOBRES & (uint32_t)VADC_GLOBRES_RESULT_Msk);" + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " * This function checks whether Result event flag is set." + NL + " */" + NL + "status_t ADC001_GetResultEvtFlag(const ADC001_HandleType* HandlePtr," + NL + "                                                            uint8_t* EvtStatus)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)" + NL + "  {" + NL + "    if(EvtStatus != NULL)" + NL + "    {" + NL + "      *EvtStatus = (uint8_t)RD_REG( VADCGlobalPtr->GLOBEFLAG," + NL + "                          VADC_GLOBEFLAG_REVGLB_Msk, VADC_GLOBEFLAG_REVGLB_Pos);" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " * This will set the result event flag through software." + NL + " */" + NL + "status_t ADC001_SetResultEvtFlag(const ADC001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)" + NL + "  {" + NL + "    SET_BIT( VADCGlobalPtr->GLOBEFLAG," + NL + "             VADC_GLOBEFLAG_REVGLB_Pos" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function clears the pending result event flag" + NL + " */" + NL + "status_t ADC001_ClearResultEvtFlag(const ADC001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)" + NL + "  {" + NL + "    SET_BIT( VADCGlobalPtr->GLOBEFLAG," + NL + "             VADC_GLOBEFLAG_REVGLBCLR_Pos" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function checks whether Channel event flag is set." + NL + " */" + NL + "status_t ADC001_GetChannelEvtFlag(const ADC001_HandleType* HandlePtr," + NL + "                                  uint8_t* EvtStatus," + NL + "                                  const ADC001_ChannelHandleType* ChannelPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint8_t GroupNo;" + NL + "  uint8_t ChannelNo;" + NL + "" + NL + "  /*Pointer to the VADC Structure */";
  protected final String TEXT_27 = NL + "  VADC_G_TypeDef *VADCGroupPtr[4];";
  protected final String TEXT_28 = NL + "  VADC_G_TypeDef *VADCGroupPtr[2];";
  protected final String TEXT_29 = NL + NL + "  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;" + NL + "  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;";
  protected final String TEXT_30 = NL + "  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;" + NL + "  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;";
  protected final String TEXT_31 = NL + "  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if((ChannelPtr != NULL) && (EvtStatus != NULL))" + NL + "    {" + NL + "      GroupNo = ChannelPtr->kGroupNo;" + NL + "      ChannelNo = ChannelPtr->kChannelNo;" + NL + "      if((GroupNo < (uint8_t)ADC001_MAX_ADC_GROUP) &&" + NL + "          (ChannelNo < (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&" + NL + "            (HandlePtr->kActiveGroups[GroupNo] == (uint8_t)1) &&" + NL + "              (HandlePtr->kActiveChannels[GroupNo][ChannelNo] == (uint8_t)1))" + NL + "      {" + NL + "        *EvtStatus = (uint8_t)RD_REG(VADCGroupPtr[GroupNo]->CEFLAG," + NL + "                      ((uint32_t)0x01 << ChannelNo)," + NL + "                      ChannelNo);" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function sets the channel event flags through software." + NL + " */" + NL + "status_t ADC001_SetChannelEvtFlag(const ADC001_HandleType* HandlePtr," + NL + "                                  const ADC001_ChannelHandleType* ChannelPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint8_t GroupNo;" + NL + "  uint8_t ChannelNo;" + NL + "" + NL + "  /*Pointer to the VADC Structure */";
  protected final String TEXT_32 = NL + "  VADC_G_TypeDef *VADCGroupPtr[4];";
  protected final String TEXT_33 = NL + "  VADC_G_TypeDef *VADCGroupPtr[2];";
  protected final String TEXT_34 = NL + NL + "  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;" + NL + "  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;";
  protected final String TEXT_35 = NL + "  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;" + NL + "  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;";
  protected final String TEXT_36 = NL + "  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(ChannelPtr != NULL)" + NL + "    {" + NL + "      GroupNo = ChannelPtr->kGroupNo;" + NL + "      ChannelNo = ChannelPtr->kChannelNo;" + NL + "      if((GroupNo < (uint8_t)ADC001_MAX_ADC_GROUP) &&" + NL + "          (ChannelNo < (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&" + NL + "            (HandlePtr->kActiveGroups[GroupNo] == (uint8_t)1) &&" + NL + "              (HandlePtr->kActiveChannels[GroupNo][ChannelNo] == (uint8_t)1))" + NL + "      {" + NL + "        SET_BIT( VADCGroupPtr[GroupNo]->CEFLAG, ChannelNo);" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function clears the pending channel event flag." + NL + " */" + NL + "status_t ADC001_ClearChannelEvtFlag(const ADC001_HandleType* HandlePtr," + NL + "                                    const ADC001_ChannelHandleType* ChannelPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint8_t GroupNo;" + NL + "  uint8_t ChannelNo;" + NL + "" + NL + "  /*Pointer to the VADC Structure */";
  protected final String TEXT_37 = NL + "  VADC_G_TypeDef *VADCGroupPtr[4];";
  protected final String TEXT_38 = NL + "  VADC_G_TypeDef *VADCGroupPtr[2];";
  protected final String TEXT_39 = NL + NL + "  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;" + NL + "  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;";
  protected final String TEXT_40 = NL + "  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;" + NL + "  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;";
  protected final String TEXT_41 = NL + "  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(ChannelPtr != NULL)" + NL + "    {" + NL + "      GroupNo = ChannelPtr->kGroupNo;" + NL + "      ChannelNo = ChannelPtr->kChannelNo;" + NL + "      if((GroupNo < (uint8_t)ADC001_MAX_ADC_GROUP) &&" + NL + "          (ChannelNo < (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&" + NL + "            (HandlePtr->kActiveGroups[GroupNo] == (uint8_t)1) &&" + NL + "              (HandlePtr->kActiveChannels[GroupNo][ChannelNo] == (uint8_t)1))" + NL + "      {" + NL + "        SET_BIT( VADCGroupPtr[GroupNo]->CEFCLR, ChannelNo);" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " * This function enables the service request after background request" + NL + " * source event." + NL + " */" + NL + "status_t ADC001_EnableBackGroundEvent(const ADC001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)" + NL + "  {" + NL + "    /* Enable background request source event service request  */" + NL + "    SET_BIT( VADCGlobalPtr->BRSMR," + NL + "             VADC_BRSMR_ENSI_Pos" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function disables the service request after background request" + NL + " * source event." + NL + " */" + NL + "status_t ADC001_DisableBackGroundEvent(const ADC001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)" + NL + "  {" + NL + "    /* Disable background request source event service request */" + NL + "    CLR_BIT( VADCGlobalPtr->BRSMR," + NL + "             VADC_BRSMR_ENSI_Pos" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " * This function checks whether source event flag is set." + NL + " */" + NL + "status_t ADC001_GetBackGroundEvtFlag(const ADC001_HandleType* HandlePtr," + NL + "                                                            uint8_t* EvtStatus)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(EvtStatus != NULL)" + NL + "    {" + NL + "      *EvtStatus = (uint8_t)RD_REG( VADCGlobalPtr->GLOBEFLAG," + NL + "                          VADC_GLOBEFLAG_SEVGLB_Msk," + NL + "                          VADC_GLOBEFLAG_SEVGLB_Pos" + NL + "                   );" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " * This function sets the source event flag through software." + NL + " */" + NL + "status_t ADC001_SetBackGroundEvtFlag(const ADC001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)" + NL + "  {" + NL + "    SET_BIT( VADCGlobalPtr->GLOBEFLAG," + NL + "             VADC_GLOBEFLAG_SEVGLB_Pos" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function clears the pending source event flag." + NL + " */" + NL + "status_t ADC001_ClearBackGroundEvtFlag(const ADC001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State != ADC001_UNINITIALIZED)" + NL + "  {" + NL + "    SET_BIT( VADCGlobalPtr->GLOBEFLAG," + NL + "             VADC_GLOBEFLAG_SEVGLBCLR_Pos" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* This function clears pending bits.*/" + NL + "status_t ADC001_ClearPendingBits(const ADC001_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    /* Clear Pending Bits */" + NL + "    SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_CLRPND_Pos);" + NL + "" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* This function generates a load event.*/" + NL + "status_t ADC001_GenerateLoadEvent(const ADC001_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    /* Generate load event */" + NL + "    SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_LDEV_Pos);" + NL + "" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function enables the gating." + NL + " */" + NL + "status_t ADC001_EnableGate(const ADC001_HandleType *HandlePtr," + NL + "                                                  uint8_t GateSelectVal)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(GateSelectVal <= (uint8_t)ADC001_GATING_ENABLED_FOR_LOW)" + NL + "    {" + NL + "      /* Selects the gating functionality */" + NL + "     WR_REG(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENGT_Msk, VADC_BRSMR_ENGT_Pos," + NL + "                                                      (uint8_t)GateSelectVal);" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " * This function gives the selected gate input level." + NL + " */" + NL + "status_t ADC001_GetGateLevel(const ADC001_HandleType* HandlePtr," + NL + "                                                            uint8_t* GeteLvlPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(GeteLvlPtr != NULL)" + NL + "    {" + NL + "      *GeteLvlPtr = (uint8_t)RD_REG( VADCGlobalPtr->BRSMR," + NL + "                                     VADC_BRSMR_REQGT_Msk," + NL + "                                     VADC_BRSMR_REQGT_Pos" + NL + "                                   );" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function sets the external trigger mode." + NL + " */" + NL + "status_t ADC001_SetExternalTriggerMode(const ADC001_HandleType *HandlePtr," + NL + "                                                         uint8_t TriggerMode)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint32_t ModeSelect;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(TriggerMode <= (uint8_t)ADC001_TRIGGER_UPON_BOTH_EDGE)" + NL + "    {" + NL + "      if(TriggerMode == (uint8_t)ADC001_NOTRIGGER)" + NL + "      {" + NL + "        /* Disables external trigger */" + NL + "        CLR_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENTR_Pos);" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        /* Enables external trigger */" + NL + "        SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENTR_Pos);" + NL + "      }" + NL + "      /* Sets the external trigger mode */" + NL + "      ModeSelect = VADCGlobalPtr->BRSCTRL;" + NL + "      ModeSelect &= ~VADC_BRSCTRL_XTMODE_Msk;" + NL + "      ModeSelect |= (uint32_t)(((uint32_t)1 << VADC_BRSCTRL_XTWC_Pos) |" + NL + "                ((uint32_t)TriggerMode << VADC_BRSCTRL_XTMODE_Pos));" + NL + "      VADCGlobalPtr->BRSCTRL = ModeSelect;" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function enables external trigger." + NL + " */" + NL + "status_t ADC001_EnableExternalTrigger(const ADC001_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    /* Enables external trigger */" + NL + "    SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENTR_Pos);" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function disables external trigger." + NL + " */" + NL + "status_t ADC001_DisableExternalTrigger(const ADC001_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    /* Disables external trigger */" + NL + "    CLR_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_ENTR_Pos);" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function enables arbitration slot." + NL;
  protected final String TEXT_42 = " */" + NL + "status_t ADC001_EnableArbitrationSlot(const ADC001_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint8_t GroupIdx;" + NL + "" + NL + "  /*Pointer to the VADC Structure */";
  protected final String TEXT_43 = NL + "  VADC_G_TypeDef *VADCGroupPtr[4];";
  protected final String TEXT_44 = NL + "  VADC_G_TypeDef *VADCGroupPtr[2];";
  protected final String TEXT_45 = NL + NL + "  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;" + NL + "  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;";
  protected final String TEXT_46 = NL + "  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;" + NL + "  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;";
  protected final String TEXT_47 = NL + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    for(GroupIdx = (uint8_t)0; GroupIdx < (uint8_t)ADC001_MAX_ADC_GROUP; GroupIdx++)" + NL + "    {" + NL + "      if(HandlePtr->kActiveGroups[GroupIdx] == (uint8_t)1)" + NL + "      {" + NL + "        SET_BIT(VADCGroupPtr[GroupIdx]->ARBPR, VADC_G_ARBPR_ASEN2_Pos);" + NL + "      }" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function disables external trigger." + NL + " */" + NL + "status_t ADC001_DisableArbitrationSlot(const ADC001_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint8_t GroupIdx;" + NL + "  /*Pointer to the VADC Structure */";
  protected final String TEXT_48 = NL + "  VADC_G_TypeDef *VADCGroupPtr[4];";
  protected final String TEXT_49 = NL + "  VADC_G_TypeDef *VADCGroupPtr[2];";
  protected final String TEXT_50 = NL + NL + "  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;" + NL + "  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;";
  protected final String TEXT_51 = NL + "  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;" + NL + "  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;";
  protected final String TEXT_52 = NL + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    for(GroupIdx = (uint8_t)0; GroupIdx < (uint8_t)ADC001_MAX_ADC_GROUP; GroupIdx++)" + NL + "    {" + NL + "      if(HandlePtr->kActiveGroups[GroupIdx] == (uint8_t)1)" + NL + "      {" + NL + "        CLR_BIT(VADCGroupPtr[GroupIdx]->ARBPR, VADC_G_ARBPR_ASEN2_Pos);" + NL + "      }" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "/*" + NL + " * This function sets the Autoscan Source Load Event Mode." + NL + " * Overwrite Mode or Combine Mode can be selected." + NL + " */" + NL + "status_t ADC001_SetLoadEventMode(const ADC001_HandleType *HandlePtr," + NL + "                                                            uint8_t EventMode)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(EventMode == (uint8_t)ADC001_OVERWRITE_MODE)" + NL + "    {" + NL + "      /* Set OverWrite Mode */" + NL + "      CLR_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_LDM_Pos);" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else if(EventMode == (uint8_t)ADC001_COMBINE_MODE)" + NL + "    {" + NL + "      /* Set Combine Mode */" + NL + "      SET_BIT(VADCGlobalPtr->BRSMR, VADC_BRSMR_LDM_Pos);" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function sets the required channel in channel pending register." + NL + " */" + NL + "status_t ADC001_SetPendingChannel(const ADC001_HandleType *HandlePtr," + NL + "                                  const ADC001_ChannelHandleType* ChannelPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "  uint8_t GroupNo;" + NL + "  uint8_t ChannelNo;" + NL + "  uint8_t GroupNoAct;" + NL + "  uint8_t ChannelNoAct;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(ChannelPtr != NULL)" + NL + "    {" + NL + "      GroupNo = ChannelPtr->kGroupNo;" + NL + "      ChannelNo = ChannelPtr->kChannelNo;" + NL + "      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];" + NL + "      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];" + NL + "" + NL + "      if((GroupNo <= (uint8_t)ADC001_MAX_ADC_GROUP) &&" + NL + "          (ChannelNo <= (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&" + NL + "            (GroupNoAct == (uint8_t)1) && (ChannelNoAct == (uint8_t)1))" + NL + "      {" + NL + "        /*set the channel*/" + NL + "        SET_BIT(VADCGlobalPtr->BRSPND[GroupNo], ChannelNo);" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function clears the required channel in channel pending register." + NL + " */" + NL + "status_t ADC001_ClearPendingChannel(const ADC001_HandleType *HandlePtr," + NL + "                                    const ADC001_ChannelHandleType* ChannelPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "  uint8_t GroupNo;" + NL + "  uint8_t ChannelNo;" + NL + "  uint8_t GroupNoAct;" + NL + "  uint8_t ChannelNoAct;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(ChannelPtr != NULL)" + NL + "    {" + NL + "      GroupNo = ChannelPtr->kGroupNo;" + NL + "      ChannelNo = ChannelPtr->kChannelNo;" + NL + "      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];" + NL + "      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];" + NL + "" + NL + "      if((GroupNo <= (uint8_t)ADC001_MAX_ADC_GROUP) &&" + NL + "            (ChannelNo <= (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&" + NL + "              (GroupNoAct == (uint8_t)1) &&(ChannelNoAct == (uint8_t)1))" + NL + "      {" + NL + "        /*Set the channel*/" + NL + "        CLR_BIT(VADCGlobalPtr->BRSPND[GroupNo], ChannelNo);" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " *This function sets the required channel in channel pending register." + NL + " */" + NL + "status_t ADC001_SetChannelSelect(const ADC001_HandleType *HandlePtr," + NL + "                                 const ADC001_ChannelHandleType* ChannelPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "  uint8_t GroupNo;" + NL + "  uint8_t ChannelNo;" + NL + "  uint8_t GroupNoAct;" + NL + "  uint8_t ChannelNoAct;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(ChannelPtr != NULL)" + NL + "    {" + NL + "      GroupNo = ChannelPtr->kGroupNo;" + NL + "      ChannelNo = ChannelPtr->kChannelNo;" + NL + "      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];" + NL + "      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];" + NL + "" + NL + "      if((GroupNo <= (uint8_t)ADC001_MAX_ADC_GROUP) &&" + NL + "          (ChannelNo <= (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&" + NL + "            (GroupNoAct == (uint8_t)1) &&(ChannelNoAct == (uint8_t)1))" + NL + "      {" + NL + "        /*set the channel*/" + NL + "        SET_BIT(VADCGlobalPtr->BRSSEL[GroupNo], ChannelNo);" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function clears the required channel in channel pending register." + NL + " */" + NL + "status_t ADC001_ClearChannelSelect(const ADC001_HandleType *HandlePtr," + NL + "                                   const ADC001_ChannelHandleType* ChannelPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Kernel Structure */" + NL + "  VADC_GLOBAL_TypeDef *VADCGlobalPtr;" + NL + "  uint8_t GroupNo;" + NL + "  uint8_t ChannelNo;" + NL + "  uint8_t GroupNoAct;" + NL + "  uint8_t ChannelNoAct;" + NL + "" + NL + "  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(ChannelPtr != NULL)" + NL + "    {" + NL + "      GroupNo = ChannelPtr->kGroupNo;" + NL + "      ChannelNo = ChannelPtr->kChannelNo;" + NL + "      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];" + NL + "      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];" + NL + "" + NL + "      if((GroupNo <= (uint8_t)ADC001_MAX_ADC_GROUP) &&" + NL + "          (ChannelNo <= (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&" + NL + "            (GroupNoAct == (uint8_t)1) &&" + NL + "              (ChannelNoAct == (uint8_t)1))" + NL + "      {" + NL + "        /*Set the channel*/" + NL + "        CLR_BIT(VADCGlobalPtr->BRSSEL[GroupNo], ChannelNo);" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " *This function sets the channel event mode." + NL + " */" + NL + "status_t ADC001_SetChannelEventMode(const ADC001_HandleType *HandlePtr," + NL + "                                    const ADC001_ChannelHandleType* ChannelPtr," + NL + "                                    uint8_t EventMode)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint8_t GroupNo;" + NL + "  uint8_t ChannelNo;" + NL + "  uint8_t GroupNoAct;" + NL + "  uint8_t ChannelNoAct;" + NL + "" + NL + "  /*Pointer to the VADC Structure */";
  protected final String TEXT_53 = NL + "  VADC_G_TypeDef *VADCGroupPtr[4];";
  protected final String TEXT_54 = NL + "  VADC_G_TypeDef *VADCGroupPtr[2];";
  protected final String TEXT_55 = NL + NL + "  VADCGroupPtr[0] = HandlePtr->VADCGroup0Ptr;" + NL + "  VADCGroupPtr[1] = HandlePtr->VADCGroup1Ptr;";
  protected final String TEXT_56 = NL + "  VADCGroupPtr[2] = HandlePtr->VADCGroup2Ptr;" + NL + "  VADCGroupPtr[3] = HandlePtr->VADCGroup3Ptr;";
  protected final String TEXT_57 = NL + NL + "  if(HandlePtr->DynamicHandlePtr->State == ADC001_INITIALIZED)" + NL + "  {" + NL + "    if(ChannelPtr != NULL)" + NL + "    {" + NL + "      GroupNo = ChannelPtr->kGroupNo;" + NL + "      ChannelNo = ChannelPtr->kChannelNo;" + NL + "      GroupNoAct = HandlePtr->kActiveGroups[GroupNo];" + NL + "      ChannelNoAct = HandlePtr->kActiveChannels[GroupNo][ChannelNo];" + NL + "" + NL + "      if((GroupNo <= (uint8_t)ADC001_MAX_ADC_GROUP) &&" + NL + "          (ChannelNo <= (uint8_t)ADC001_MAX_ADC_GROUP_CHANNEL) &&" + NL + "            (GroupNoAct == (uint8_t)1) &&" + NL + "              (ChannelNoAct == (uint8_t)1) &&" + NL + "                ((EventMode == (uint8_t)ADC001_CHANNEL_EVENT_NEVER) ||" + NL + "                    (EventMode == (uint8_t)ADC001_CHANNEL_EVENT_ALWAYS)))" + NL + "      {" + NL + "        WR_REG( VADCGroupPtr[GroupNo]->CHCTR[ChannelNo]," + NL + "          VADC_G_CHCTR_CHEVMODE_Msk," + NL + "          VADC_G_CHCTR_CHEVMODE_Pos," + NL + "          (uint32_t)EventMode" + NL + "         );" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC001_INVALID_PARAM_ERROR;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);" + NL + "  }" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "/**" + NL + " * @endcond" + NL + " */" + NL + "/*CODE_BLOCK_END*/";
  protected final String TEXT_58 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
     int Is44Device = -1; 
     int Is42Device = -1; 
     int Is45Device = -1; 
     Is44Device = ((app.getSoftwareId().substring(0,2).compareTo("44")==0)?1:0); 
     Is42Device = ((app.getSoftwareId().substring(0,2).compareTo("42")==0)?1:0); 
     Is45Device = ((app.getSoftwareId().substring(0,2).compareTo("45")==0)?1:0); 
    stringBuffer.append(TEXT_1);
     String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null;
   boolean DBGApp = false;
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}
//   }
  } 
    stringBuffer.append(TEXT_2);
     if (!DBGApp) { 
    stringBuffer.append(TEXT_3);
     } 
    stringBuffer.append(TEXT_4);
     String AppBaseuri = "app/ADC001/"; 
     String appInst  = null; 
     String ConfigUri = null; 
     String kernelUri = null; 
     String kernelNo = null; 
    stringBuffer.append(TEXT_5);
     ArrayList<String> appsList = (ArrayList<String>)(app.getApps("app/ADC001/"));
for (String appIns : appsList ) {
    appInst = appIns.substring(appIns.lastIndexOf("/")+1);
    stringBuffer.append(TEXT_6);
    }
    stringBuffer.append(TEXT_7);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_8);
    } else {
    stringBuffer.append(TEXT_9);
    }
    stringBuffer.append(TEXT_10);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_11);
     } 
    stringBuffer.append(TEXT_12);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_13);
     } 
    stringBuffer.append(TEXT_14);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_15);
    } else {
    stringBuffer.append(TEXT_16);
    }
    stringBuffer.append(TEXT_17);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_18);
     } 
    stringBuffer.append(TEXT_19);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_20);
     } 
    stringBuffer.append(TEXT_21);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_22);
    } else {
    stringBuffer.append(TEXT_23);
    } 
    stringBuffer.append(TEXT_24);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_25);
    }
    stringBuffer.append(TEXT_26);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_27);
     } else {
    stringBuffer.append(TEXT_28);
    } 
    stringBuffer.append(TEXT_29);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_30);
     } 
    stringBuffer.append(TEXT_31);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_32);
     } else {
    stringBuffer.append(TEXT_33);
    } 
    stringBuffer.append(TEXT_34);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_35);
     } 
    stringBuffer.append(TEXT_36);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_37);
     } else {
    stringBuffer.append(TEXT_38);
    } 
    stringBuffer.append(TEXT_39);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_40);
     } 
    stringBuffer.append(TEXT_41);
    stringBuffer.append(TEXT_42);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_43);
    } else {
    stringBuffer.append(TEXT_44);
    }
    stringBuffer.append(TEXT_45);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_46);
     } 
    stringBuffer.append(TEXT_47);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_48);
    } else {
    stringBuffer.append(TEXT_49);
    }
    stringBuffer.append(TEXT_50);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_51);
     } 
    stringBuffer.append(TEXT_52);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_53);
    } else {
    stringBuffer.append(TEXT_54);
    }
    stringBuffer.append(TEXT_55);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_56);
     } 
    stringBuffer.append(TEXT_57);
    stringBuffer.append(TEXT_58);
    return stringBuffer.toString();
  }
}
