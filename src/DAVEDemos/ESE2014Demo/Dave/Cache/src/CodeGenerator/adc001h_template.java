package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class adc001h_template
{
  protected static String nl;
  public static synchronized adc001h_template create(String lineSeparator)
  {
    nl = lineSeparator;
    adc001h_template result = new adc001h_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/******************************************************************************" + NL + " *" + NL + " * Copyright (C) 2013 Infineon Technologies AG. All rights reserved." + NL + " *" + NL + " * Infineon Technologies AG (Infineon) is supplying this software for use with" + NL + " * Infineon's microcontrollers." + NL + " * This file can be freely distributed within development tools that are" + NL + " * supporting such microcontrollers." + NL + " *" + NL + " * THIS SOFTWARE IS PROVIDED \"AS IS\".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED" + NL + " * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF" + NL + " * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE." + NL + " * INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL," + NL + " * OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER." + NL + " *" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR   : DAVE App Developer                                              **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Sep 27, 2013                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** CM           DAVE App Developer                                            **" + NL + "** ---------------------------------------------------------------------------**" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @file ADC001.h" + NL + " *" + NL + " * @brief This header file contains the data structures and function prototypes " + NL + " *        of ADC001 App" + NL + " *" + NL + " * Change History:" + NL + " *" + NL + " * Date         version       Details" + NL + " * 16-Dec-2012   1.0.4    Initial code added for XMC1000" + NL + " * 06-Mar-2013   1.0.6    App version changed for XMC1000 and XMC4400/XMC4200" + NL + " * 24-Apr-2013   1.0.8    Ported to XMC4500 step AB and" + NL + " *                        Source Result selection Feature added" + NL + " * 11-Jun-2013   1.0.10   1. In channel selection page Group C and Group D check " + NL + " *                        boxes made invisible for XMC1200/1300/4200 devices." + NL + " *                        2. In the Header comment section device name changed" + NL + " *                           to XMC1000." + NL + " *                        3. Tooltip for the Group channel selection is modified." + NL + " *                        4. New api ADC001_GetFastResult() implemented." + NL + " *                        5. Source Result register selection feature disabled" + NL + " *                           due to header file update not available.     " + NL + " * 27-Jun-2013   1.0.12   Source Result register selection feature removed to" + NL + " *                        simplify the app." + NL + " * 27-Sep-2013   1.0.16   Typos in API Documentation & .h comments is corrected." + NL + " */" + NL + "#ifndef ADC001_H_" + NL + "#define ADC001_H_" + NL + "" + NL + "#ifdef __cplusplus" + NL + "extern \"C\" {" + NL + "#endif" + NL + "" + NL + "/*****************************************************************************" + NL + " * INCLUDE FILES" + NL + " *****************************************************************************/" + NL + "#include <DAVE3.h>" + NL + "" + NL + "" + NL + "/******************************************************************************" + NL + "**                      Global Macro Definitions                              **" + NL + "*******************************************************************************/" + NL + "/** Maximum service request nodes */" + NL + "#define ADC001_MAX_SERVICE_REQUEST_NODE  4" + NL + "" + NL + "/** Maximum ADC group */";
  protected final String TEXT_2 = NL + "#define ADC001_MAX_ADC_GROUP   4";
  protected final String TEXT_3 = NL + "#define ADC001_MAX_ADC_GROUP   2";
  protected final String TEXT_4 = NL + NL + "/** Maximum ADC channels per group */" + NL + "#define ADC001_MAX_ADC_GROUP_CHANNEL  8" + NL + "" + NL + "/** Total number of ADC channels */";
  protected final String TEXT_5 = NL + "#define ADC001_TOTAL_ADC_CHANNEL    32";
  protected final String TEXT_6 = NL + "#define ADC001_TOTAL_ADC_CHANNEL    16";
  protected final String TEXT_7 = NL + NL + "/** Maximum group specific boundary */" + NL + "#define ADC001_MAX_BOUNDARY_VALUE  4096" + NL + "" + NL + "/** Maximum sample time control register value */" + NL + "#define ADC001_MAX_SAMPLE_TIME_CONTROL_VAL  32" + NL + "/*******************************************************************************" + NL + "**                      Global Type Definitions                               **" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @ingroup ADC001_publicparam" + NL + " * @{" + NL + " */" + NL + "/*******************************************************************************" + NL + " *                                ENUMERATIONS                                **" + NL + " ******************************************************************************/" + NL + "/**" + NL + " * This enumerates the state of the App." + NL + " */" + NL + "typedef enum ADC001_StateType" + NL + "{" + NL + "  /**" + NL + "   * This is the Default state of an APP after power on reset." + NL + "   */" + NL + "  ADC001_UNINITIALIZED," + NL + "  /**" + NL + "   * This is the INITIALIZED state in which APP is initialized as per selected" + NL + "   * parameters." + NL + "   */" + NL + "  ADC001_INITIALIZED" + NL + "}ADC001_StateType;" + NL + "" + NL + "" + NL + "/**" + NL + " * This will enumerate the error codes which will be returned from a function." + NL + " */" + NL + "typedef enum ADC001_ErrorCodesType" + NL + "{" + NL + "  /**" + NL + "   * This code would be returned when any operation is not possible cause that" + NL + "   * operation was tried in invalid state" + NL + "   */" + NL + "    /*" + NL + "    GROUPID  #41" + NL + "    MODULENAME = ADC001" + NL + "    */" + NL + "    /*" + NL + "    ERRCODESTRING = ADC001_OPER_NOT_ALLOWED_ERROR" + NL + "    STRCODESTRING = Function execution is not allowed in the current state" + NL + "    */  " + NL + "  ADC001_OPER_NOT_ALLOWED_ERROR = 1," + NL + "  /**" + NL + "   * This code is returned when parameter passed to API are invalid" + NL + "   */" + NL + "  /*" + NL + "  ERRCODESTRING = ADC001_INVALID_PARAM_ERROR" + NL + "  STRCODESTRING = Input parameter is not valid" + NL + "  */ " + NL + "  ADC001_INVALID_PARAM_ERROR," + NL + "  /*" + NL + "  ERRCODESTRING = ADCCH001_INVALID_RESULT" + NL + "  STRCODESTRING = Conversion result is invalid" + NL + "  */  " + NL + "  ADC001_INVALID_RESULT,  " + NL + "  /** Debug log messages */" + NL + "  /**" + NL + "   * Message Id for function Entry" + NL + "   */" + NL + "  /*" + NL + "  ERRCODESTRING = ADC001_FUN_ENTRY" + NL + "  STRCODESTRING = Function entered" + NL + "  */ " + NL + "  ADC001_FUNCTION_ENTRY," + NL + "  /**" + NL + "   * Message ID for function exit" + NL + "   */" + NL + "  /*" + NL + "  ERRCODESTRING = ADC001_FUN_EXIT" + NL + "  STRCODESTRING = Function exited" + NL + "  */ " + NL + "  ADC001_FUNCTION_EXIT," + NL + "}ADC001_ErrorCodesType;" + NL + "" + NL + "" + NL + "/**" + NL + " * This enumerates the enable or disable of associated arbitration slot." + NL + " */" + NL + "typedef enum ADC001_ArbitrationSlot" + NL + "{" + NL + "  /**" + NL + "   * Disable the arbitration slot" + NL + "   */" + NL + "  ADC001_ARBITRATION_SLOT_DISABLE = 0," + NL + "  /**" + NL + "   * Enable the arbitration slot" + NL + "   */" + NL + "  ADC001_ARBITRATION_SLOT_ENABLE" + NL + "}ADC001_ArbitrationSlot;" + NL + "" + NL + "" + NL + "/**" + NL + " * This enumerates the start conversion after initialization." + NL + " */" + NL + "typedef enum ADC001_ConversionAfterInit" + NL + "{" + NL + "  /**" + NL + "   * Disable start conversion after initialization" + NL + "   */" + NL + "  ADC001_START_CONV_DISABLE = 0," + NL + "  /**" + NL + "   * Enable conversion after initialization" + NL + "   */" + NL + "  ADC001_START_CONV_ENABLE" + NL + "}ADC001_ConversionAfterInit;" + NL + "" + NL + "" + NL + "/**" + NL + " * This enumerates the auto scan functionality " + NL + " */" + NL + "typedef enum ADC001_Autoscan" + NL + "{" + NL + "  /**" + NL + "   * Auto scan functionality disabled" + NL + "   */" + NL + "  ADC001_AUTOSCAN_DISABLE = 0," + NL + "  /**" + NL + "   * Auto scan functionality enabled" + NL + "   */" + NL + "  ADC001_AUTOSCAN_ENABLE" + NL + "}ADC001_Autoscan;" + NL + "" + NL + "/**" + NL + " * This enumerates the result position alignment." + NL + " */" + NL + "typedef enum ADC001_PosAlign" + NL + "{" + NL + "  /**" + NL + "   * Result is Left aligned." + NL + "   */" + NL + "  ADC001_LEFT_ALIGN = 0," + NL + "  /**" + NL + "   * Result is Right aligned." + NL + "   */" + NL + "  ADC001_RIGHT_ALIGN" + NL + "}ADC001_PosAlign;" + NL + "" + NL + "" + NL + "/**" + NL + " * This enumerates the global input class" + NL + " */" + NL + "typedef enum ADC001_GlobalInPutClass" + NL + "{" + NL + "  /**" + NL + "   * Global input class 0" + NL + "   */" + NL + "  ADC001_GLOBAL_CLASS0 = 2," + NL + "  /**" + NL + "   * Global input class 1" + NL + "   */" + NL + "  ADC001_GLOBAL_CLASS1 " + NL + "}ADC001_GlobalInPutClass;" + NL + "" + NL + "" + NL + "/**" + NL + " * This enumerates the gating mode." + NL + " */" + NL + "typedef enum ADC001_GatingMode" + NL + "{" + NL + "  /**" + NL + "   * Gating is disabled." + NL + "   */" + NL + "  ADC001_GATING_DISABLED=0," + NL + "  /**" + NL + "   * Gating is enabled always." + NL + "   */" + NL + "  ADC001_GATING_ENABLED_ALWAYS=1," + NL + "  /**" + NL + "   * Gating is enabled for high level." + NL + "   */" + NL + "  ADC001_GATING_ENABLED_FOR_HIGH=2," + NL + "  /**" + NL + "   * Gating is enabled for low level." + NL + "   */" + NL + "  ADC001_GATING_ENABLED_FOR_LOW=3," + NL + "}ADC001_GatingMode;" + NL + "" + NL + "" + NL + "/**" + NL + " * This enumerates the external trigger mode." + NL + " */" + NL + "typedef enum ADC001_TriggerMode" + NL + "{" + NL + "  /**" + NL + "   * External trigger disabled" + NL + "   */" + NL + "  ADC001_NOTRIGGER=0," + NL + "  /**" + NL + "   * External trigger on falling edge" + NL + "   */" + NL + "  ADC001_TRIGGER_UPON_FALLING_EDGE=1," + NL + "  /**" + NL + "   * External trigger on rising edge" + NL + "   */" + NL + "  ADC001_TRIGGER_UPON_RISING_EDGE=2," + NL + "  /**" + NL + "   * External trigger on both edges" + NL + "   */" + NL + "  ADC001_TRIGGER_UPON_BOTH_EDGE=3," + NL + "}ADC001_TriggerMode;" + NL + "" + NL + "/**" + NL + " * This enumerates the priority." + NL + " */" + NL + "typedef enum ADC001_Priority" + NL + "{" + NL + "  /**" + NL + "   * App priority 0" + NL + "   */" + NL + "  ADC001_PRIORITY0=0," + NL + "  /**" + NL + "   * App priority 1" + NL + "   */" + NL + "  ADC001_PRIORITY1=1," + NL + "  /**" + NL + "   * App priority2" + NL + "   */" + NL + "  ADC001_PRIORITY2=2," + NL + "  /**" + NL + "   * App priority 3" + NL + "   */" + NL + "  ADC001_PRIORITY3=3," + NL + "}ADC001_Priority;" + NL + "" + NL + "" + NL + "/**" + NL + " * This enumerates the autoscan source load event mode" + NL + " */" + NL + "typedef enum ADC001_LoadEventMode" + NL + "{" + NL + "  /**" + NL + "   * Copy all bits from the select registers to the" + NL + "   * pending registers upon a load event." + NL + "   */" + NL + "  ADC001_OVERWRITE_MODE = 0," + NL + "  /**" + NL + "   * Set all pending bits that are set in the select" + NL + "   * registers upon a load event (logic OR)" + NL + "   */" + NL + "  ADC001_COMBINE_MODE" + NL + "}ADC001_LoadEventMode;" + NL + "" + NL + "" + NL + "/**" + NL + " * This enumerates the channel event mode" + NL + " */" + NL + "typedef enum ADC001_ChannelEventMode" + NL + "{" + NL + "  /**" + NL + "   * Channel event disabled" + NL + "   */" + NL + "  ADC001_CHANNEL_EVENT_NEVER = 0," + NL + "  /**" + NL + "   * Channel event occurs if result is inside boundary" + NL + "   */" + NL + "  ADC001_CHANNEL_EVENT_INSIDE_BOUNDARY," + NL + "  /**" + NL + "   * Channel event occurs if result is outside boundary" + NL + "   */" + NL + "  ADC001_CHANNEL_EVENT_OUTSIDE_BOUNDARY," + NL + "  /**" + NL + "   * Channel event enabled" + NL + "   */" + NL + "  ADC001_CHANNEL_EVENT_ALWAYS," + NL + "}ADC001_ChannelEventMode;" + NL + "" + NL + "/**" + NL + " * This enumerates the start mode" + NL + " */" + NL + "typedef enum ADC001_StartMode" + NL + "{" + NL + "  /**" + NL + "   * Wait for start mode" + NL + "   * The requested channel is sampled after the current conversion " + NL + "   * has finished" + NL + "   */" + NL + "  ADC001_WAIT_FOR_START = 0," + NL + "  /**" + NL + "   * Cancel inject Repeat mode" + NL + "   * After an injected conversion has finished,the interrupted conversion " + NL + "   * request is injected into the pipeline,hence the measurement is repeated." + NL + "   */" + NL + "  ADC001_CANCEL_INJECT_REPEAT=1," + NL + "  /**" + NL + "   * Cancel inject Repeat mode with cancel mode" + NL + "   * In case of an ongoing conversion, this conversion is cancelled, the requested" + NL + "   * channel is sampled and converted immediately." + NL + "   */" + NL + "   ADC001_CANCEL_INJECT_REPEAT_WITH_CANCEL=2," + NL + "}ADC001_StartMode;" + NL + "" + NL + "" + NL + "/**" + NL + " * This enumerates the result read mode" + NL + " */" + NL + "typedef enum ADC001_ResultReadMode" + NL + "{" + NL + "" + NL + "  /**" + NL + "   * Result overwrite mode" + NL + "   * Result will be overwritten whether previous result is read or not " + NL + "   */" + NL + "  ADC001_RESULT_OVERWRITE_MODE = 0," + NL + "" + NL + "  /**" + NL + "   * Wait for read mode" + NL + "   * Result will be updated only if previous result is read" + NL + "   */" + NL + "  ADC001_WAIT_FOR_READ = 1" + NL + "}ADC001_ResultReadMode;" + NL + "" + NL + "" + NL + "/**" + NL + " * This structure holds the parameters which change at run time." + NL + " */" + NL + "typedef struct ADC001_DynamicDataType" + NL + "{" + NL + "  /**" + NL + "   * This is group number of the channel corresponding to the value in global result register." + NL + "   */" + NL + "  uint8_t GroupNo;" + NL + "  /**" + NL + "   * This is channel number corresponding to the value in global result register." + NL + "   */" + NL + "  uint8_t ChannelNo;" + NL + "  /** This is the result of the conversion */" + NL + "  uint16_t Result;" + NL + "  /**" + NL + "   * This enumerates the state of the App." + NL + "   */" + NL + "  ADC001_StateType State;" + NL + "}ADC001_DynamicDataType;" + NL + "" + NL + "/**" + NL + " * This structure holds all the static configuration parameters of the Event" + NL + " * Counter APP." + NL + " */" + NL + "typedef struct ADC001_HandleType" + NL + "{" + NL + "  /**" + NL + "   * This is ADC group number." + NL + "   */" + NL + "  const uint8_t kGroupNo;" + NL + "  /**" + NL + "   * This is total number of ADC channels selected." + NL + "   */" + NL + "  const uint8_t kChannels;  " + NL + "  /**" + NL + "   * This contains combined value of channels selected for Scan sequence" + NL + "   * from group 0 " + NL + "   */  " + NL + "  const uint8_t kGroup0ChSelect;" + NL + "  /**" + NL + "   * This contains combined value of channels selected for Scan sequence" + NL + "   * from group 1 " + NL + "   */  " + NL + "  const uint8_t kGroup1ChSelect;  ";
  protected final String TEXT_8 = NL + "  /**" + NL + "   * This contains combined value of channels selected for Scan sequence" + NL + "   * from group 2 " + NL + "   */  " + NL + "  const uint8_t kGroup2ChSelect;" + NL + "  /**" + NL + "   * This contains combined value of channels selected for Scan sequence" + NL + "   * from group 3 " + NL + "   */  " + NL + "  const uint8_t kGroup3ChSelect;";
  protected final String TEXT_9 = NL + "  /**" + NL + "   * This is number of ADC channels selected from Group A." + NL + "   */" + NL + "  const uint8_t kGrpAChannels;" + NL + "  /**" + NL + "   * This is number of ADC channels selected from Group B." + NL + "   */" + NL + "  const uint8_t kGrpBChannels;";
  protected final String TEXT_10 = NL + "  /**" + NL + "   * This is number of ADC channels selected from Group C." + NL + "   */" + NL + "  const uint8_t kGrpCChannels;" + NL + "  /**" + NL + "   * This is number of ADC channels selected from Group D." + NL + "   */" + NL + "  const uint8_t kGrpDChannels; " + NL + "  /*" + NL + "   * This indicates Active channels." + NL + "   */" + NL + "  uint8_t kActiveChannels[4][8];";
  protected final String TEXT_11 = NL + "  /*" + NL + "     * This indicates Active channels." + NL + "     */" + NL + "  uint8_t kActiveChannels[2][8];";
  protected final String TEXT_12 = NL + "  " + NL + "  /*" + NL + "   * This indicates Active groups." + NL + "   */" + NL + "  uint8_t kActiveGroups[4];  " + NL + "  /**" + NL + "   * This is to enable or disable arbitration slot." + NL + "   */" + NL + "  const uint8_t kAsenEnable;" + NL + "  /**" + NL + "   * This is to select conversion start mode." + NL + "   */" + NL + "  const uint8_t kStart;" + NL + "  /**" + NL + "   * This is priority of request source." + NL + "   */" + NL + "  const uint8_t kPriority;" + NL + "  /**" + NL + "   * This is to select external trigger mode." + NL + "   */" + NL + "  const uint8_t kTriggerMode;" + NL + "  /**" + NL + "   * This is to enable or disable external trigger mode." + NL + "   */  " + NL + "  const uint8_t kTriggerEn;" + NL + "  /**" + NL + "   * This is to select gating mode." + NL + "   */" + NL + "  const uint8_t kGatingMode;" + NL + "  /**" + NL + "   * This is to select result read mode." + NL + "   */  " + NL + "  const uint8_t kResultReadMode;" + NL + "  /**" + NL + "   * This is to select conversion start mode." + NL + "   */  " + NL + "  const uint8_t kStartmode;  " + NL + "  /**" + NL + "   * This is to enable or disable auto scan mode. " + NL + "   */" + NL + "  const uint8_t kAutoScan;" + NL + "  /**" + NL + "   * This is to control the result alignment. " + NL + "   */" + NL + "  const uint8_t kResultControl;" + NL + "  /**" + NL + "   * This is to enable or disable result event. " + NL + "   */  " + NL + "  const uint8_t kResultEvtEnable;" + NL + "  /**" + NL + "   * This is to enable or disable resource event. " + NL + "   */  " + NL + "  const uint8_t kResourceEvtEnable;" + NL + "  /**" + NL + "   * This is to select input class. " + NL + "   */  " + NL + "  const uint8_t kIpClassSel;" + NL + "  /**" + NL + "   * This is the pointer to the structure which holds the parameters which " + NL + "   * change at run time." + NL + "   */" + NL + "  ADC001_DynamicDataType * DynamicHandlePtr;" + NL + "  /**" + NL + "   * This is the pointer to the VADC Global Registers." + NL + "   */" + NL + "  VADC_GLOBAL_TypeDef* VADCGlobalPtr;" + NL + "  /**" + NL + "   * This is the pointer to the VADC group 0 Registers." + NL + "   */" + NL + "  VADC_G_TypeDef* VADCGroup0Ptr;" + NL + "  /**" + NL + "   * This is the pointer to the VADC group 1 Registers." + NL + "   */  " + NL + "  VADC_G_TypeDef* VADCGroup1Ptr;";
  protected final String TEXT_13 = NL + "  /**" + NL + "   * This is the pointer to the VADC group 2 Registers." + NL + "   */  " + NL + "  VADC_G_TypeDef* VADCGroup2Ptr;" + NL + "  /**" + NL + "   * This is the pointer to the VADC group 3 Registers." + NL + "   */  " + NL + "  VADC_G_TypeDef* VADCGroup3Ptr;";
  protected final String TEXT_14 = "  " + NL + "}ADC001_HandleType;" + NL + "" + NL + "" + NL + "/**" + NL + " * This is the channel handle." + NL + " */  " + NL + "typedef struct ADC001_ChannelHandleType" + NL + "{" + NL + "  /**" + NL + "   * This is group number of assigned channel." + NL + "   */" + NL + "  const uint8_t kGroupNo;" + NL + "  /**" + NL + "   * This is channel number of assigned channel." + NL + "   */  " + NL + "  const uint8_t kChannelNo;" + NL + "  /**" + NL + "   * This is to enable or disable the channel for scan sequence." + NL + "   */  " + NL + "  const uint8_t kEnable;" + NL + "}ADC001_ChannelHandleType;" + NL + "" + NL + "" + NL + "/**" + NL + " * This is the result handle." + NL + " */" + NL + "typedef struct ADC001_ResultHandleType" + NL + "{" + NL + "  /**" + NL + "   * This is group number of the channel corresponding to the value in global result register." + NL + "   */" + NL + "  uint8_t GroupNo;" + NL + "  /**" + NL + "   * This is channel number corresponding to the value in global result register." + NL + "   */" + NL + "  uint8_t ChannelNo;" + NL + "  /**" + NL + "   * This is the value of conversion result." + NL + "   */" + NL + "  uint16_t Result;" + NL + "}ADC001_ResultHandleType;" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "/**" + NL + " * @ingroup ADC001_apidoc" + NL + " * @{" + NL + " */" + NL + " " + NL + "/*******************************************************************************" + NL + "** FUNCTION PROTOTYPES                                                        **" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @brief This function initializes the ADC background App with the configured" + NL + " * parameters." + NL + " * @return None <BR>" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *    DAVE_Init(); //ADC001_Init is called within DAVE_Init" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "void ADC001_Init(void);" + NL + "" + NL + "/**" + NL + " * @brief This function resets the App." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: if the function is successful.<BR><BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *    //Call the deinit function to reset the app to default values." + NL + " *    Status = " + NL + " *          ADC001_Deinit((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_Deinit(const ADC001_HandleType* HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function selects the global input class for the channel." + NL + " * @param[in] HandlePtr pointer to the Instance variable" + NL + " * @param[in] Class Global input class number" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in " + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: if the selected class number is other than     " + NL + " *                                   global class<BR>" + NL + " * " + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Set group specific boundary 0." + NL + " *    Status =" + NL + " *          ADC001_SelectInputClass(" + NL + " *            (ADC001_HandleType*)&ADC001_Handle0, ADC001_GLOBAL_CLASS0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " *" + NL + " */" + NL + "status_t ADC001_SelectInputClass(const ADC001_HandleType* HandlePtr, " + NL + "                                                 ADC001_GlobalInPutClass Class);" + NL + "/**" + NL + " * @brief This function enables the result event. This is enabled for global result register and" + NL + " * as global result register is shared by all the channels it is applicable for all the conversions." + NL + " * @param[in] HandlePtr pointer to the Instance variable" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b> <BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    uint16_t Result;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    // Enable Result event service request" + NL + " *    Status =" + NL + " *          ADC001_EnableResultEvt((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_EnableResultEvt(const ADC001_HandleType* HandlePtr);" + NL + "                                                          " + NL + "/**" + NL + " * @brief This function disables the result event." + NL + " * @param[in] HandlePtr pointer to the Instance variable" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b> <BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    uint16_t Result;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Disable Result event service request" + NL + " *    Status =" + NL + " *          ADC001_DisableResultEvt((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_DisableResultEvt(const ADC001_HandleType* HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function returns the result of the normal mode ADC conversion." + NL + " *        Result read mode is configured as \"wait-for-read\". <b>Use this API to read result" + NL + " *        of each conversion so that next background scan conversion result can be written into the global result register.</b>" + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] ResultPtr Pointer to store conversion result.<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: if the ResultPtr is NULL.<BR>" + NL + " * ADC001_INVALID_RESULT : If the result is not updated. <BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    ADC001_ResultHandleType Result;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Get the result" + NL + " *    Status =" + NL + " *          ADC001_GetResult(" + NL + " *            (ADC001_HandleType*)&ADC001_Handle0, &Result);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_GetResult(const ADC001_HandleType* HandlePtr, " + NL + "                                            ADC001_ResultHandleType* ResultPtr);" + NL + "/**" + NL + " * @brief This function returns the result of the normal mode ADC conversion without checking the valid bitfield." + NL + " *        Result read mode is configured as \"wait-for-read\". <b>Use this API to read result" + NL + " *        of each conversion so that next background scan conversion result can be written into the global result register.</b>" + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @return <b>uint16_t</b><BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    uint32_t AdcResult;" + NL + "  *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Get the result" + NL + " *    AdcResult =  ADC001_GetFastResult((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */ " + NL + "uint16_t ADC001_GetFastResult(const ADC001_HandleType* HandlePtr);" + NL + "                      " + NL + "/**" + NL + " * @brief This function checks whether Result event flag is set." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] EvtStatus Pointer to store the status of result event flag.<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: if EvtStatus is NULL.<BR><BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    uint8_t ResultEvt;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Get result event flag" + NL + " *    Status =" + NL + " *          ADC001_GetResultEvtFlag(" + NL + " *            (ADC001_HandleType*)&ADC001_Handle0, &ResultEvt);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_GetResultEvtFlag(const ADC001_HandleType* HandlePtr, " + NL + "                                                            uint8_t* EvtStatus);" + NL + "" + NL + "/**" + NL + " * @brief This function sets the result event flag through software." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Set result event flag" + NL + " *    Status =" + NL + " *          ADC001_SetResultEvtFlag((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_SetResultEvtFlag(const ADC001_HandleType* HandlePtr);" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief This function clears the pending result event flag." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Clear result event flag" + NL + " *    Status =" + NL + " *          ADC001_ClearResultEvtFlag((ADC001_HandleType*)&ADC001_Handle0, 1);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_ClearResultEvtFlag(const ADC001_HandleType* HandlePtr);" + NL + "/**" + NL + " * @brief This function checks whether Channel event flag is set." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] EvtStatus Pointer to hold the status of channel event flag." + NL + " * @param[in] ChannelPtr Pointer to the Channel handle" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: if EvtStatus or ChannelPtr is NULL." + NL + " *                                   if the group number or channel number in" + NL + " *                                   channel handle is invalid or not consumed<BR><BR>" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    uint8_t ChEvtStat;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Get channel event flag status" + NL + " *    Status =" + NL + " *          ADC001_GetChannelEvtFlag(" + NL + " *            (ADC001_HandleType*)&ADC001_Handle0, &ChEvtStat, &ADC001_ChannelAAHandle);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_GetChannelEvtFlag(const ADC001_HandleType* HandlePtr, " + NL + "                                  uint8_t* EvtStatus," + NL + "                                  const ADC001_ChannelHandleType* ChannelPtr);" + NL + "" + NL + "/**" + NL + " * @brief This function sets the channel event flags through software." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] ChannelPtr Pointer to the Channel handle" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL;
  protected final String TEXT_15 = " * ADC001_INVALID_PARAM_ERROR: if the ChannelPtr is NULL." + NL + " *                                   if the group number or channel number in" + NL + " *                                   channel handle is invalid or not consumed<BR><BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Set Channel event flag." + NL + " *    Status =" + NL + " *          ADC001_SetChannelEvtFlag(" + NL + " *            (ADC001_HandleType*)&ADC001_Handle0, &ADC001_ChannelAAHandle);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_SetChannelEvtFlag(const ADC001_HandleType* HandlePtr," + NL + "                                  const ADC001_ChannelHandleType* ChannelPtr);" + NL + "" + NL + "/**" + NL + " * @brief This function clears the pending channel event flag." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] ChannelPtr Pointer to the Channel handle<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in   " + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: if the ChannelPtr is NULL.   " + NL + " *                                   if the group number or channel number in" + NL + " *                                   channel handle is invalid or not consumed<BR><BR>" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    uint8_t StartSelect;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Clear channel event flag" + NL + " *    Status =" + NL + " *          ADC001_ClearChannelEvtFlag(" + NL + " *            (ADC001_HandleType*)&ADC001_Handle0, &ADC001_ChannelAAHandle);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_ClearChannelEvtFlag(const ADC001_HandleType* HandlePtr," + NL + "                                    const ADC001_ChannelHandleType* ChannelPtr);" + NL + "" + NL + "/**" + NL + " * @brief This function enables the background request" + NL + " *        source event. This event is generated after all the conversions in the" + NL + " *        background scan sequence are finished." + NL + " * @param[in] HandlePtr pointer to the Instance variable" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * <b>Reentrant: yes</b> <BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    uint8_t EvtflgStat;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    // Enable background request source event service request." + NL + " *    Status =" + NL + " *          ADC001_EnableBackGroundEvent((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_EnableBackGroundEvent(const ADC001_HandleType* HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function disables the background request" + NL + " *        source event." + NL + " * @param[in] HandlePtr pointer to the Instance variable" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * <b>Reentrant: yes</b> <BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    uint8_t EvtflgStat;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Disable background request source event service request." + NL + " *    Status =" + NL + " *          ADC001_DisableBackGroundEvent((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_DisableBackGroundEvent(const ADC001_HandleType* HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function checks whether background source event flag is set." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] EvtStatus Pointer to store the status of background even flag<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: if the EvtStatus is NULL.   <BR>" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    uint8_t EvtflgStat;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Set EMUX channel select value." + NL + " *    Status =" + NL + " *          ADC001_GetBackGroundEvtFlag(" + NL + " *            (ADC001_HandleType*)&ADC001_Handle0, &EvtflgStat);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_GetBackGroundEvtFlag(const ADC001_HandleType* HandlePtr, " + NL + "                                                           uint8_t* EvtStatus);" + NL + "" + NL + "/**" + NL + " * @brief This function sets the background source event flag through software." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " * " + NL + " * DAVEApp_SUCCESS: if the function is successful<BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " * ADC001_UNINITIALIZED State.<BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Set EMUX Mode." + NL + " *    Status =" + NL + " *          ADC001_SetBackGroundEvtFlag((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_SetBackGroundEvtFlag(const ADC001_HandleType* HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function clears the background resource event flag." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful. <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Clears background request source event. " + NL + " *    Status =" + NL + " *         ADC001_ClearBackGroundEvtFlag((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_ClearBackGroundEvtFlag(const ADC001_HandleType* HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function clears pending bits." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Clear pending bits." + NL + " *    Status =" + NL + " *          ADC001_ClearPendingBits((ADC001_HandleType*)&ADC001_Handle0;" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_ClearPendingBits(const ADC001_HandleType *HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function generates a load event for the background scan sequence." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Generate load event" + NL + " *    Status =" + NL + " *          ADC001_GenerateLoadEvent((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_GenerateLoadEvent(const ADC001_HandleType *HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function enables the gating feature." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] GateSelectVal Gate selection value<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " * ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: if the GateSelectVal value is above " + NL + " *                                   ADC001_GATING_ENABLED_FOR_LOW<BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Enable gating" + NL + " *    Status =" + NL + " *          ADC001_EnableGate((ADC001_HandleType*)&ADC001_Handle0," + NL + " *                            ADC001_GATING_ENABLED_FOR_LOW);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + " " + NL + " " + NL + "status_t ADC001_EnableGate(const ADC001_HandleType *HandlePtr, " + NL + "                                              uint8_t GateSelectVal);" + NL + "                                              " + NL + "                                              " + NL + "/**" + NL + " * @brief This function gives the selected gate signal input level." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] GeteLvlPtr Selected Gate level value<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " * " + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " * ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: if the GeteLvlPtr value is NULL.<BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    uint8_t GateLevel;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Get selected gate input level." + NL + " *    Status =" + NL + " *          ADC001_GetGateLevel((ADC001_HandleType*)&ADC001_Handle0," + NL + " *                                                                &GateLevel);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_GetGateLevel(const ADC001_HandleType* HandlePtr, " + NL + "                                                          uint8_t* GeteLvlPtr);" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief This function sets the external trigger mode. It enables the external trigger" + NL + " * when mode is non-zero." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] TriggerMode Value of external trigger mode<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: If TriggerMode > 3 <BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Set external trigger mode." + NL + " *    Status =" + NL + " *          ADC001_SetExternalTriggerMode((ADC001_HandleType*)&ADC001_Handle0," + NL + " *                                               ADC001_TRIGGER_UPON_BOTH_EDGE);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_SetExternalTriggerMode(const ADC001_HandleType *HandlePtr, " + NL + "                                                         uint8_t TriggerMode);" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief This function enables external trigger." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * " + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL;
  protected final String TEXT_16 = " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Enable external trigger." + NL + " *    Status =" + NL + " *          ADC001_EnableExternalTrigger((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_EnableExternalTrigger(const ADC001_HandleType *HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function disables external trigger." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Disables the external trigger." + NL + " *    Status =" + NL + " *          ADC001_DisableExternalTrigger((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_DisableExternalTrigger(const ADC001_HandleType *HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function enables background scan arbitration slot." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Enable arbitration slot for background request source." + NL + " *    Status =" + NL + " *          ADC001_EnableArbitrationSlot((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_EnableArbitrationSlot(const ADC001_HandleType *HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function disables background scan arbitration slot." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Disable arbitration slot for background request source. " + NL + " *    Status =" + NL + " *          ADC001_DisableArbitrationSlot((ADC001_HandleType*)&ADC001_Handle0);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_DisableArbitrationSlot(const ADC001_HandleType *HandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief This function sets the Autoscan Source Load Event Mode.<BR>" + NL + " *        Overwrite Mode or Combine Mode can be selected." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] EventMode Value of event mode<BR> " + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: If the EventMode value is apart from " + NL + " *                             ADC001_OVERWRITE_MODE or ADC001_COMBINE_MODE. <BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Set conversion mode for standard conversion in group input class 0." + NL + " *    Status =" + NL + " *          ADC001_SetLoadEventMode(" + NL + " *            (ADC001_HandleType*)&ADC001_Handle0, ADC001_COMBINE_MODE);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_SetLoadEventMode(const ADC001_HandleType *HandlePtr, " + NL + "                                                             uint8_t EventMode);" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief This function sets the required channel in channel pending register." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] ChannelPtr Pointer to the channel handle<BR> " + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: If the ChannelPtr is NULL." + NL + " *                             if the group number or channel number in" + NL + " *                             channel handle is invalid or not consumed<BR><BR> " + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Set pending bit for channels to include in the conversion" + NL + " *    Status =" + NL + " *          ADC001_SetPendingChannel(" + NL + " *            (ADC001_HandleType*)&ADC001_Handle0, &ADC001_ChannelAAHandle);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_SetPendingChannel(const ADC001_HandleType *HandlePtr," + NL + "                                  const ADC001_ChannelHandleType* ChannelPtr);" + NL + "" + NL + "/**" + NL + " * @brief This function clears the required channel in channel pending register." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] ChannelPtr Pointer to the Channel handle<BR> " + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: If the ChannelPtr is NULL." + NL + " *                             if the group number or channel number in" + NL + " *                             channel handle is invalid or not consumed<BR><BR> " + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Clear pending bit for channels to exclude from the conversion." + NL + " *    Status =" + NL + " *          ADC001_ClearPendingChannel(" + NL + " *            (ADC001_HandleType*)&ADC001_Handle0, &ADC001_ChannelAAHandle);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_ClearPendingChannel(const ADC001_HandleType *HandlePtr," + NL + "                                    const ADC001_ChannelHandleType* ChannelPtr);" + NL + "                                          " + NL + "/**" + NL + " * @brief This function selects the channel for conversion. It adds one channel at " + NL + " * a time in the background scan sequence." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] ChannelPtr Pointer to the channel handle<BR> " + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: If the ChannelPtr is NULL." + NL + " *                             if the group number or channel number in" + NL + " *                             channel handle is invalid or not consumed<BR><BR>  " + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Select channel for conversion." + NL + " *    Status =" + NL + " *          ADC001_SetChannelSelect((ADC001_HandleType*)&ADC001_Handle0, " + NL + " *                                   &ADC001_ChannelAAHandle);" + NL + " *    Status =" + NL + " *          ADC001_SetChannelSelect((ADC001_HandleType*)&ADC001_Handle0, " + NL + " *                                   &ADC001_ChannelBDHandle);" + NL + " *    Status =" + NL + " *          ADC001_SetChannelSelect((ADC001_HandleType*)&ADC001_Handle0, " + NL + " *                                   &ADC001_ChannelBAHandle);" + NL + " *                                   " + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_SetChannelSelect(const ADC001_HandleType *HandlePtr," + NL + "                                 const ADC001_ChannelHandleType* ChannelPtr);" + NL + "                                          " + NL + "/**" + NL + " * @brief This function clears the required channel from channel pending register." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] ChannelPtr Pointer to the channel handle<BR> " + NL + " * @return <b>status_t</b><BR>" + NL + " *" + NL + " * DAVEApp_SUCCESS: if the function is successful <BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: If the ChannelPtr is NULL." + NL + " *                             if the group number or channel number in" + NL + " *                             channel handle is invalid or not consumed<BR><BR>" + NL + " *" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Clear channel from scan sequence." + NL + " *    Status =" + NL + " *          ADC001_ClearChannelSelect((ADC001_HandleType*)&ADC001_Handle0, " + NL + " *                                    &ADC001_ChannelAAHandle);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_ClearChannelSelect(const ADC001_HandleType *HandlePtr," + NL + "                                   const ADC001_ChannelHandleType* ChannelPtr);" + NL + "                                          " + NL + "/**" + NL + " * @brief This function sets the channel event mode." + NL + " * @param[in] HandlePtr pointer to the Instance variable<BR>" + NL + " * @param[in] ChannelPtr Pointer to the channel handle<BR>" + NL + " * @param[in] EventMode Channel event mode" + NL + " * @return <b>status_t</b><BR>" + NL + " * " + NL + " * DAVEApp_SUCCESS: if the function is successful<BR>" + NL + " * ADC001_OPER_NOT_ALLOWED_ERROR: If the function is called when in" + NL + " *                          ADC001_UNINITIALIZED State. <BR>" + NL + " * ADC001_INVALID_PARAM_ERROR: If the ChannelPtr is NULL." + NL + " *                             EventMode value is apart from ADC001_CHANNEL_EVENT_NEVER" + NL + " *                             or ADC001_CHANNEL_EVENT_ALWAYS. <BR>" + NL + " * <b>Reentrant: yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * int main(void)" + NL + " * {" + NL + " *    status_t Status;" + NL + " *    DAVE_Init();//ADC001_Init is called within DAVE_Init" + NL + " *" + NL + " *    //Set channel event mode" + NL + " *    Status = " + NL + " *    ADC001_SetChannelEventMode((ADC001_HandleType*)&ADC001_Handle0, &ADC001_ChannelAAHandle, " + NL + " *                                              ADC001_CHANNEL_EVENT_ALWAYS);" + NL + " *    while(1);" + NL + " *    return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t ADC001_SetChannelEventMode(const ADC001_HandleType *HandlePtr," + NL + "                                    const ADC001_ChannelHandleType* ChannelPtr," + NL + "                                    uint8_t EventMode);" + NL + "" + NL + "#include \"ADC001_Conf.h\"" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "#ifdef __cplusplus" + NL + "}" + NL + "#endif" + NL + "  " + NL + "#endif /* ADC001_H_ */";
  protected final String TEXT_17 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
     int Is44Device = -1; 
     int Is42Device = -1; 
     int Is45Device = -1; 
     int Is1xDevice = -1; 
     Is44Device = ((app.getSoftwareId().substring(0,2).compareTo("44")==0)?1:0); 
     Is42Device = ((app.getSoftwareId().substring(0,2).compareTo("42")==0)?1:0); 
     Is45Device = ((app.getSoftwareId().substring(0,2).compareTo("45")==0)?1:0); 
     Is1xDevice = ((app.getSoftwareId().substring(0,1).compareTo("1")==0)?1:0); 
    stringBuffer.append(TEXT_1);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_2);
    } else {
    stringBuffer.append(TEXT_3);
    }
    stringBuffer.append(TEXT_4);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_5);
    } else {
    stringBuffer.append(TEXT_6);
    }
    stringBuffer.append(TEXT_7);
     if(Is1xDevice != 1) {
    stringBuffer.append(TEXT_8);
     } 
    stringBuffer.append(TEXT_9);
     if(Is1xDevice != 1) {
    stringBuffer.append(TEXT_10);
     } else {
    stringBuffer.append(TEXT_11);
     } 
    stringBuffer.append(TEXT_12);
     if(Is45Device == 1 || Is44Device == 1 ) {
    stringBuffer.append(TEXT_13);
     } 
    stringBuffer.append(TEXT_14);
    stringBuffer.append(TEXT_15);
    stringBuffer.append(TEXT_16);
    stringBuffer.append(TEXT_17);
    return stringBuffer.toString();
  }
}
