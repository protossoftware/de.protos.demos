RoomModel room.basic.service.can {

	import room.basic.types.* from "Types.room"

	import room.basic.service.timing.* from "TimingService.room"

	ActorClass ACANService {
		Interface {
			SPP canTx: PCANTx
			SPP canRx: PCANRx
		}
		Structure {
			usercode1 {
				"/*uc1*/"
			}
			usercode2 {
				"/*uc2*/"
			} usercode3 {
				"/*uc3 */"
				"#include \"pclCANService.h\""
			}
			ServiceImplementation of canTx
			ServiceImplementation of canRx
			SAP timer: PTimer
			Attribute rxData [ 10 ]: DCANData
			Attribute txData [ 10 ]: DCANData
			Attribute pollTime: uint32 = "50"
		}
		Behavior {
			Operation pollAllRxMsgs() {
				"pclCANMsg msg;"
				"uint32 i;"
				"uint8 val;"
				"uint32 numberOfPorts = PCANRxReplPort_getReplication(&(self->constData->canRx));"
				"for(i=0;i<numberOfPorts;i++){"
				"	if (PCL_TRUE == pclCANCheckReception(rxData[i].channel, &msg)){"
				"		canRx_msgReceived(i, &msg);"
				"		}"
				"	}"
			}
			StateMachine {
				Transition init: initial -> Operational {
					action {
						"timer.startTimer(pollTime);\npclCANInitNodes();"
					}
				}
				Transition tr0: Operational -> Operational {
					triggers {
						<sendMsg: canTx>
					}
					action {
						"uint32 c;\n\nc =txData[((etReplSubPort*)ifitem)->index].channel;\npclCANSendMsg(c,data);"
					}
				}
				Transition tr1: Operational -> Operational {
					triggers {
						<init: canTx>
					}
					action {
						"txData[((etReplSubPort*)ifitem)->index].channel = data;"
						"pclCANInitMO(data);"
					}
				}
				Transition tr2: Operational -> Operational {
					triggers {
						<init: canRx>
					}
					action {
						"rxData[((etReplSubPort*)ifitem)->index].channel = data;"
						"pclCANInitMO(data);"
					}
				}
				Transition tr3: Operational -> Operational {
					triggers {
						<timeout: timer>
					}
					action {
						"pollAllRxMsgs();"
					}
				}
				Transition tr4: Operational -> Operational {
					triggers {
						<listenOnMsg: canRx>
					}
					action {
						"uint32 c;\n\nc =rxData[((etReplSubPort*)ifitem)->index].channel;\npclCANListenOnMsg(c,data);"
					}
				}
				State Operational
			}
		}
	}

	ProtocolClass PCANRx {
		usercode1 {
			"#include \"pclCANService.h\""
			"#define ET_CAN_CHANNEL_NOT_DEFINED			0xFFFFFFFF"
		}
		incoming {
			Message init(data: uint32)
			Message readMsg()
			Message listenOnMsg(data: pclCANMsg)
			Message transmitRequest()
		}
		outgoing {
			Message msgReceived(data: pclCANMsg)
		}
		conjugated PortClass
		{
			handle
			incoming init {
				"ET_MSC_LOGGER_SYNC_ENTRY(\"PCANRxConjPort\", \"init\")"
				"if(data__et != ET_CAN_CHANNEL_NOT_DEFINED) pChannel = data__et;"
				"etPort_sendMessage(self, PCANRx_IN_init, sizeof(uint32), &pChannel);"
				"ET_MSC_LOGGER_SYNC_EXIT"
			}
			Attribute pChannel: uint32 = " ET_CAN_CHANNEL_NOT_DEFINED " [ " must be set by configuration " ]
		}
	}

	ProtocolClass PCANTx {
		usercode1 {
			"#include \"pclCANService.h\""
			"#define ET_CAN_CHANNEL_NOT_DEFINED			0xFFFFFFFF"
		}
		incoming {
			Message init(data: uint32)
			Message sendMsg(data: pclCANMsg)
			Message resendMsg()
		}
		outgoing {
			Message valueChanged(data: uint8)
		}
		conjugated PortClass
		{
			handle
			incoming init {
				"ET_MSC_LOGGER_SYNC_ENTRY(\"PCANTxConjPort\", \"init\")"
				"if(data__et != ET_CAN_CHANNEL_NOT_DEFINED) pChannel=data__et;"
				"etPort_sendMessage(self, PCANTx_IN_init, sizeof(uint32), &pChannel);"
				"ET_MSC_LOGGER_SYNC_EXIT"
			}
			Attribute pChannel: uint32 = " ET_CAN_CHANNEL_NOT_DEFINED " [ " must be set by configuration " ]
		}
	}

	DataClass DCANData {
		Attribute channel: uint32 = " ET_CAN_CHANNEL_NOT_DEFINED "
	}

	ExternalType pclCANMsg -> "pclCANMsg"
}