RoomModel Elevator_Model [
"This is a demo for the modelleling tool eTrice! 
 eTrice provides an implementation of the modelling language ROOM (Realtime Object Oriented Modelling! ROOM is a spezialized language  
for embedded realtime systems. It provides a run to completion semantics. ETrice provides generators for Java, C and Latex. "
] {

	import room.basic.types.* from "Types.room"
	import room.basic.service.timing.* from "TimingService.room"
	import room.basic.service.serial.* from "SerialService.room"
	import room.basic.annotations.* from "Annotations.room"
	import room.basic.service.gpio.* from "pclGPIOService.room"

	LogicalSystem Elevator_LogSys {
		SubSystemRef elevator_subSysRef: Elevator_LogSubSys
	}

	SubSystemClass Elevator_LogSubSys [
	"The subsystem represents an address space. A subsystem may contain threads if the underlaying operating system provides 
multithreading. The demo platform is a single threaded platform. The subsystem contains all elements to control the elevator HW. 
The instance diagram provides an overview of the generated instances."
	] {
		ActorRef elevator: ElevatorTop
		ActorRef timingService: ATimingService
		ActorRef ioService: AIOBitService
		ActorRef ioReg8Service: AIORegister8Service
		LayerConnection ref elevator satisfied_by timingService.timer
		LayerConnection ref elevator satisfied_by ioService.iobitOut
		LayerConnection ref elevator satisfied_by ioService.iobitIn
		LayerConnection ref ioService satisfied_by timingService.timer
		LayerConnection ref elevator satisfied_by ioReg8Service.ioReg8Out
		LayerConnection ref ioReg8Service satisfied_by timingService.timer
		LogicalThread defaultThread
		LogicalThread midPrioThread
		LogicalThread timingThread
		ActorInstanceMapping elevator/top -> midPrioThread
		ActorInstanceMapping timingService -> timingThread
	}
 ActorClass AFloorContainer {
	Interface {
			Port p0 [5]: PFloorControl
		}
	Structure {
			ActorRef floors [5]: AFloorController
			Binding p0 and floors.ControlPort
		}
	Behavior {
	}
}
	ActorClass AElevatorMainController [ "The main Controller provides the strategie for the elevator!" ] {
		Interface {
			conjugated Port CabinePort: PCabineControl [ "Port to the cabine" ]
			conjugated Port MotorPort: PMotorControl [ "Port to control the motor of the elevator" ]
			conjugated Port FloorPort [5]: PFloorControl [ "Port to control the floors" ]
			Port controlPort: PMainControllerStatus
		}
		Structure {
			external Port CabinePort
			external Port MotorPort
			external Port FloorPort
			external Port controlPort
			conjugated Port HelperPort: PStartGenerator
			ActorRef helper: AStartGenerator
			SAP timer: PTimer
			Binding HelperPort and helper.ControlPort
			Attribute floor: uint8 [ "current position of the cabine" ]
			Attribute doorStatus: uint8 [ "contains the status of the door (open/close)" ]
			Attribute upRequests [ 5 ]: uint8 [ "1 if a request exist above the current cabine position" ]
			Attribute downRequests [ 5 ]: uint8 [ "1 if arequest exists below the current cabine position  " ]
			Attribute idleTime: uint8 [ "after this time without requests, the cabine goes to the idle floor " ]
			Attribute idleFloor: uint8 [ "the floor where the cabine waits for requests " ]
			Attribute reportState: uint8 [ "state that is reported to the outside world" ]
			Attribute idleRequest: uint8 [ "flag that idle state is requested" ]
			Attribute floorRequest: uint8 [ "flag that a floor message should be sent" ]
		}
		Behavior {
			Operation clearFloorRequests() [
			"clear all actual floor requests and send an appropriate message to the floors and the cabine." ] {
				"
				FloorPort[floor].requestsClear();
				CabinePort.floorRequestClear(floor);
				upRequests[floor]=0;
				downRequests[floor]=0;
				"
			}
			Operation clearAllRequests() {
			"
				uint8 i;
				for(i=0;i<5;i++){
					FloorPort[i].requestsClear();
					CabinePort.floorRequestClear(i);			
					upRequests[i]=0;
					downRequests[i]=0;
					}
			"
			}
			Operation isRequestHere(): uint8 {
				"
				if(upRequests[floor] || downRequests[floor]) return 1;
				return 0;	
				"
			}
			Operation isRequestAbove(): uint8 {
				"
				signed char i;
				if (floor == 4) return 0;
				for(i=floor+1;i<5;i++){
					if(upRequests[i] || downRequests[i]) return 1;
				}
				return 0;
				"
			}
			Operation isRequestBelow(): uint8 {
				"
				signed char i;
				if (floor == 0) return 0;
				for(i=floor-1;i>=0;i--){
					if(upRequests[i] || downRequests[i]) return 1;
				}
				return 0;
				"
			}
			StateMachine {
				Transition init: initial -> idle {
					action {
						"unsigned char i;\nfor(i=0;i<5;i++){\n\tFloorPort[i].setFloor(i);\n\tupRequests[i]=0;\n\tdownRequests[i]=0;\n}\nfloor=0;\nMotorPort.goUpOneFloor();\nidleRequest=0;\nreportState=0;\n//idleFloor=2;\nidleTime=10;"
					}
				}
				Transition tr0: my tp0 -> my tp0 {
					triggers {
						<floorReached: MotorPort>
					}
					action {
						"CabinePort.set7seg(data+1);"
						"floor=data;"
					}
				}
				Transition tr7: cp cp0 -> tp0 of idle {
					action {
						"FloorPort[floor].openDoor();"
						"CabinePort.openDoor();"
						"clearFloorRequests();"
					}
				}
				Transition tr8: cp cp0 -> tp0 of goingDown {
					cond {
						"isRequestBelow()"
					}
				}
				Transition tr9: cp cp0 -> tp0 of goingUp {
					cond {
						"isRequestAbove()"
					}
				}
				Transition tr5: tp2 of goingDown -> tp1 of goingUp
				Transition tr6: tp3 of goingDown -> tp2 of idle
				Transition tr11: tp2 of goingUp -> tp3 of idle
				Transition tr12: tp3 of goingUp -> tp1 of goingDown
				Transition tr1: my tp1 -> my tp1 {
					triggers {
						<requestUp: FloorPort>
					}
					action {
						"unsigned char idx=((etReplSubPort*)ifitem)->index;"
						"FloorPort[idx].requestUpAck();"
						"upRequests[idx]=1;"
						"HelperPort.requestCheck();"
					}
				}
				Transition tr2: my tp1 -> my tp1 {
					triggers {
						<requestDown: FloorPort>
					}
					action {
						"unsigned char idx=((etReplSubPort*)ifitem)->index;"
						"FloorPort[idx].requestDownAck();"
						"downRequests[idx]=1;"
						"HelperPort.requestCheck();"
					}
				}
				Transition tr3: my tp1 -> my tp1 {
					triggers {
						<floorRequest: CabinePort>
					}
					action {
						"CabinePort.floorRequestAck(data);"
						"upRequests[data]=1;"
						"downRequests[data]=1;"
						"HelperPort.requestCheck();"
					}
				}
				Transition tr4: tp1 of idle -> cp cp0
				Transition tr10: my tp2 -> my tp2 {
					triggers {
						<check: HelperPort>
					}
				}
				Transition tr15: my tp3 -> my tp3 {
					triggers {
						<requestIdle: controlPort>
					}
					action {
						"idleRequest=1;"
					}
				}
				Transition tr16: my tp3 -> my tp3 {
					triggers {
						<getStatus: controlPort>
					}
					action {
						"uint32 d;"
						"uint8 r=0, i, mask;"
						""
						"d = floor;"
						"d<<=8;"
						"d |= reportState;"
						"d<<=8;"
						""
						"mask=1;"
						"for(i=0;i<5;i++){"
						"\tif(upRequests[i] || downRequests[i]) r|=mask;"
						"\tmask<<=1;"
						"\t}"
						"d |= r;"
						""
						"controlPort.status(d);"
					}
				}
				Transition tr17: my tp3 -> my tp3 {
					triggers {
						<requestFloor: controlPort>
					}
					action {
						"floorRequest=1;"
					}
				}
				Transition tr18: my tp4 -> my tp4 {
					triggers {
						<setIdleFloor: controlPort>
					}
					action {
						"if (data < 5){"
						"\tidleFloor=data;"
						"\t}"
					}
				}
				Transition tr13: my tp4 -> my tp4 {
					triggers {
						<setIdleTime: controlPort>
					}
					action {
						"if (data < 60){"
						"\tidleTime=data;"
						"\t}"
					}
				}
				ChoicePoint cp0
				handler TransitionPoint tp0
				handler TransitionPoint tp1
				handler TransitionPoint tp2
				handler TransitionPoint tp3
				handler TransitionPoint tp4
				State idle {
					entry {
						"if(idleRequest){"
						"\tidleRequest=0;"
						"\tclearAllRequests();"
						"\tcontrolPort.idle();"
						"\t}"
					}
					subgraph {
						Transition tr0: my tp0 -> doorOpen {
							action {
								"doorStatus=0;"
							}
						}
						Transition tr1: doorOpen -> cp cp0 {
							triggers {
								<done: CabinePort>
							}
							action {
								"doorStatus++;"
							}
						}
						Transition tr2: doorOpen -> cp cp0 {
							triggers {
								<done: FloorPort>
							}
							action {
								"doorStatus++;"
							}
						}
						Transition tr3: cp cp0 -> doorOpen
						Transition tr4: cp cp0 -> doorClosed {
							cond {
								"doorStatus>1"
							}
							action {
								"if (isRequestAbove() || isRequestBelow()){"
								"HelperPort.requestCheck();"
								"}"
							}
						}
						Transition tr5: doorClosed -> my tp1 {
							triggers {
								<check: HelperPort>
							}
							action {
								"timer.kill();"
							}
						}
						Transition tr6: my tp2 -> doorClosed
						Transition tr7: my tp3 -> doorClosed
						Transition init: initial -> doorClosed
						Transition tr8: doorOpen -> doorOpen {
							triggers {
								<check: HelperPort>
							}
							action {
								"if (isRequestHere()){"
								"\tCabinePort.openDoor();"
								"\tFloorPort[floor].openDoor();"
								"\tdoorStatus=0;"
								"\tclearFloorRequests();"
								"}"
							}
						}
						Transition tr10: doorClosed -> doorOpen {
							triggers {
								<doorRequest: CabinePort>
							}
							action {
								"FloorPort[floor].openDoor();"
								"CabinePort.openDoor();"
								"doorStatus=0;"
								"timer.kill();"
							}
						}
						Transition tr11: doorOpen -> doorOpen {
							triggers {
								<doorRequest: CabinePort>
							}
							action {
								"FloorPort[floor].openDoor();"
								"CabinePort.openDoor();"
								"doorStatus=0;"
							}
						}
						Transition tr12: my tp4 -> my tp4 {
							triggers {
								<requestIdle: controlPort>
							}
							action {
								"controlPort.idle();"
							}
						}
						Transition tr9: doorClosed -> tp0 of moveToIdleFloor {
							triggers {
								<timeout: timer>
							}
						}
						Transition tr13: tp1 of moveToIdleFloor -> doorClosed {
							action {
								"if (isRequestHere() || isRequestAbove() || isRequestBelow() ) {\n\tHelperPort.requestCheck();\n}"
							}
						}
						ChoicePoint cp0
						EntryPoint tp0
						ExitPoint tp1
						EntryPoint tp2
						EntryPoint tp3
						handler TransitionPoint tp4
						State doorOpen {
							entry {
								"reportState=4;"
							}
						}
						State doorClosed {
							entry {
								"reportState=3;\n\nif ( (floor!=idleFloor) && (idleTime > 0) ) {\n\ttimer.startTimeout(idleTime * 1000);\t\n}\n\n\n//if ( (floor!=idleFloor) && (idleTime > 0) ) {\n//\ttimer.startTimeout(idleTime * 1000);\t\n//}\n//transitioncode:\n//upRequests[idleFloor]=1;"
							}
						}
						State moveToIdleFloor {
							subgraph {
								Transition tr0: my tp0 -> cp cp0
								Transition tr1: cp cp0 -> my tp1
								Transition tr2: cp cp0 -> moveToIdle {
									cond {
										"(floor < idleFloor)"
									}
									action {
										"MotorPort.goUpOneFloor();"
									}
								}
								Transition tr3: cp cp0 -> moveToIdle {
									cond {
										"(floor > idleFloor)"
									}
									action {
										"MotorPort.goDownOneFloor();"
									}
								}
								Transition tr4: cp cp1 -> my tp1
								Transition tr5: moveToIdle -> cp cp1 {
									triggers {
										<floorReached: MotorPort>
									}
									action {
										"floor = data;"
										"CabinePort.set7seg(data+1);"
									}
								}
								Transition tr6: cp cp1 -> moveToIdle {
									cond {
										"(floor < idleFloor)"
									}
									action {
										"MotorPort.goUpOneFloor();"
									}
								}
								Transition tr7: cp cp1 -> moveToIdle {
									cond {
										"(floor > idleFloor)"
									}
									action {
										"MotorPort.goDownOneFloor();"
									}
								}
								ChoicePoint cp0
								ChoicePoint cp1
								EntryPoint tp0
								ExitPoint tp1
								State moveToIdle
							}
						}
					}
				}
				State goingDown {
					subgraph {
						Transition tr0: my tp0 -> running
						Transition tr1: running -> cp cp0 {
							triggers {
								<floorReached: MotorPort>
							}
							action {
								"floor=data;"
								"CabinePort.set7seg(data+1);"
							}
						}
						Transition tr2: cp cp0 -> running
						Transition tr3: cp cp0 -> halted {
							cond {
								"downRequests[floor] || !isRequestBelow()"
							}
							action {
								"clearFloorRequests();"
								"if (floorRequest){"
								"\tfloorRequest=0;"
								"\tcontrolPort.floor(floor);}"
								""
								"FloorPort[floor].openDoor();"
								"CabinePort.openDoor();"
								"doorStatus=0;"
							}
						}
						Transition tr10: my tp1 -> running
						Transition tr9: cp cp2 -> cp cp3
						Transition tr11: cp cp2 -> running {
							cond {
								"isRequestBelow()"
							}
						}
						Transition tr12: cp cp3 -> my tp3
						Transition tr13: cp cp3 -> my tp2 {
							cond {
								"isRequestAbove()"
							}
						}
						Transition tr14: halted -> cp cp4 {
							triggers {
								<done: CabinePort>
							}
							action {
								"doorStatus++;"
							}
						}
						Transition tr15: halted -> cp cp4 {
							triggers {
								<done: FloorPort>
							}
							action {
								"doorStatus++;"
							}
						}
						Transition tr16: cp cp4 -> halted
						Transition tr4: cp cp4 -> cp cp1 {
							cond {
								"doorStatus>1"
							}
						}
						Transition tr5: halted -> halted {
							triggers {
								<check: HelperPort>
							}
							action {
								"if (isRequestHere()){"
								"\tCabinePort.openDoor();"
								"\tFloorPort[floor].openDoor();"
								"\tdoorStatus=0;"
								"\tclearFloorRequests();"
								"}"
							}
						}
						Transition tr6: halted -> halted {
							triggers {
								<doorRequest: CabinePort>
							}
							action {
								"FloorPort[floor].openDoor();"
								"CabinePort.openDoor();"
								"doorStatus=0;"
							}
						}
						Transition tr7: cp cp1 -> cp cp2
						Transition tr8: cp cp1 -> my tp3 {
							cond {
								"idleRequest"
							}
						}
						ChoicePoint cp0
						ChoicePoint cp2
						ChoicePoint cp3
						ChoicePoint cp4
						ChoicePoint cp1
						EntryPoint tp0
						EntryPoint tp1
						ExitPoint tp2
						ExitPoint tp3
						State running {
							entry {
								"MotorPort.goDownOneFloor();"
								"reportState=2;"
							}
						}
						State halted {
							entry {
								"reportState=4;"
							}
						}
					}
				}
				State goingUp {
					entry {
						"reportState=1;"
					}
					subgraph {
						Transition tr0: my tp0 -> running
						Transition tr1: running -> cp cp0 {
							triggers {
								<floorReached: MotorPort>
							}
							action {
								"floor=data;"
								"CabinePort.set7seg(data+1);"
							}
						}
						Transition tr2: cp cp0 -> running
						Transition tr3: cp cp0 -> halted {
							cond {
								"upRequests[floor] || !isRequestAbove()"
							}
							action {
								"clearFloorRequests();"
								"if (floorRequest){"
								"\tfloorRequest=0;"
								"\tcontrolPort.floor(floor);}"
								""
								"FloorPort[floor].openDoor();"
								"CabinePort.openDoor();"
								"doorStatus=0;"
							}
						}
						Transition tr7: cp cp1 -> halted
						Transition tr8: cp cp1 -> cp cp4 {
							cond {
								"doorStatus>1"
							}
						}
						Transition tr9: cp cp2 -> cp cp3
						Transition tr10: cp cp2 -> running {
							cond {
								"isRequestAbove()"
							}
						}
						Transition tr13: my tp1 -> running
						Transition tr11: cp cp3 -> my tp2
						Transition tr12: cp cp3 -> my tp3 {
							cond {
								"isRequestBelow()"
							}
						}
						Transition tr5: halted -> cp cp1 {
							triggers {
								<done: CabinePort>
							}
							action {
								"doorStatus++;"
							}
						}
						Transition tr6: halted -> cp cp1 {
							triggers {
								<done: FloorPort>
							}
							action {
								"doorStatus++;"
							}
						}
						Transition tr4: halted -> halted {
							triggers {
								<check: HelperPort>
							}
							action {
								"if (isRequestHere()){"
								"\tCabinePort.openDoor();"
								"\tFloorPort[floor].openDoor();"
								"\tdoorStatus=0;"
								"\tclearFloorRequests();"
								"}"
							}
						}
						Transition tr14: halted -> halted {
							triggers {
								<doorRequest: CabinePort>
							}
							action {
								"FloorPort[floor].openDoor();"
								"CabinePort.openDoor();"
								"doorStatus=0;"
							}
						}
						Transition tr15: cp cp4 -> cp cp2
						Transition tr16: cp cp4 -> my tp2 {
							cond {
								"idleRequest"
							}
						}
						ChoicePoint cp0
						ChoicePoint cp1
						ChoicePoint cp2
						ChoicePoint cp3
						ChoicePoint cp4
						EntryPoint tp0
						EntryPoint tp1
						ExitPoint tp2
						ExitPoint tp3
						State running {
							entry {
								"MotorPort.goUpOneFloor();"
								"reportState=1;"
							}
						}
						State halted {
							entry {
								"reportState=4;"
							}
						}
					}
				}
			}
		}
	}

	ActorClass AElevatorSecurityController {
		Interface {
			conjugated Port motorPort: PMotorControl
			conjugated Port serialCommandhandlerPort: PSerialCommandHandler
			conjugated Port floorPort [5]: PFloorControl
			conjugated Port cabinePort: PCabineControl
		}
		Structure {
			usercode3 {
				"extern unsigned char etStartupParam;"
			}
			external Port serialCommandhandlerPort
			external Port cabinePort
			Port iCabinePort: PCabineControl
			conjugated Port iMainControllerPort: PMainControllerStatus
			ActorRef mainController: AElevatorMainController
			SAP timer: PTimer
			Binding iCabinePort and mainController.CabinePort
			Binding motorPort and mainController.MotorPort
			Binding iMainControllerPort and mainController.controlPort
			Binding floorPort and mainController.FloorPort
			Attribute validFloors: uint8
			Attribute secTime: uint32
		}
		Behavior {
			Operation checkFloor(floor: uint8): uint8 {
			"
				uint8 mask=1;
				
				mask <<= floor;
				if (validFloors & mask) {
					return 1;}
				return 0;
				"
			}
			StateMachine {
				Transition tr3: my tp2 -> my tp2 {
					triggers {
						<set7seg: iCabinePort>
					}
					action {
						"cabinePort.set7seg(data);"
					}
				}
				Transition tr7: my tp2 -> my tp2 {
					triggers {
						<openDoor: iCabinePort>
					}
					action {
						"cabinePort.openDoor();"
					}
				}
				Transition tr8: my tp2 -> my tp2 {
					triggers {
						<closeDoor: iCabinePort>
					}
					action {
						"cabinePort.closeDoor();"
					}
				}
				Transition tr9: my tp3 -> my tp3 {
					triggers {
						<floorRequestAck: iCabinePort>
					}
					action {
						"cabinePort.floorRequestAck(data);"
					}
				}
				Transition tr10: my tp3 -> my tp3 {
					triggers {
						<floorRequestClear: iCabinePort>
					}
					action {
						"cabinePort.floorRequestClear(data);"
					}
				}
				Transition tr14: my tp5 -> my tp5 {
					triggers {
						<floorRequest: cabinePort>
					}
					action {
						"iCabinePort.floorRequest(data);"
					}
				}
				Transition tr15: my tp5 -> my tp5 {
					triggers {
						<doorRequest: cabinePort>
					}
					action {
						"iCabinePort.doorRequest();"
					}
				}
				Transition tr16: my tp5 -> my tp5 {
					triggers {
						<done: cabinePort>
					}
					action {
						"iCabinePort.done();"
					}
				}
				Transition tr25: my tp6 -> my tp6 {
					triggers {
						<statusRequest: serialCommandhandlerPort>
					}
					action {
						"iMainControllerPort.getStatus();"
					}
				}
				Transition tr26: my tp6 -> my tp6 {
					triggers {
						<status: iMainControllerPort>
					}
					action {
						"serialCommandhandlerPort.status(data);"
					}
				}
				Transition init: initial -> tp0 of secureMode
				handler TransitionPoint tp2
				handler TransitionPoint tp3
				handler TransitionPoint tp5
				handler TransitionPoint tp6
				State normalMode {
					entry {
						"iMainControllerPort.setIdleTime(10);"
						"iMainControllerPort.setIdleFloor(2);"
					}
				}
				State secureMode {
					subgraph {
						Transition tr0: my tp0 -> idle {
							action {
								"iMainControllerPort.setIdleFloor(0);"
								"iMainControllerPort.setIdleTime(0);"
							}
						}
						Transition tr1: idle -> waitForCabineRequests {
							triggers {
								<floorRelease: serialCommandhandlerPort>
							}
							action {
								"secTime = data & 0x00FF;"
								"validFloors = (data >> 8) & 0x00FF;"
								"// Floor 1 is always selected"
								"validFloors |= 0x01;"
								"cabinePort.startIndicateFloors(validFloors);"
								"timer.startTimeout(secTime * 1000);"
								"serialCommandhandlerPort.releaseAck(1);"
							}
						}
						Transition tr2: cp cp0 -> waitForCabineRequests {
							action {
								"if (data & 0x80) serialCommandhandlerPort.requestAck(2);"
							}
						}
						Transition tr3: waitForCabineRequests -> cp cp0 {
							triggers {
								<floorRequest: cabinePort>
								or
								<floorRequest: serialCommandhandlerPort>
							}
						}
						Transition tr4: cp cp0 -> floorRequested {
							cond {
								"checkFloor(data & 0x7F)"
							}
							action {
								"uint8 mask = 1;"
								"if (data & 0x80) serialCommandhandlerPort.requestAck(1);"
								"data &= 0x7F;"
								"// send a new floor list to indicate"
								"cabinePort.stopIndicateFloors();"
								"mask<<=data;"
								"validFloors &= ~mask;"
								"cabinePort.startIndicateFloors(validFloors);"
								""
								"iCabinePort.floorRequest(data);"
								"iMainControllerPort.requestFloor();"
							}
						}
						Transition tr5: cp cp1 -> floorRequested {
							action {
								"if (data & 0x80) serialCommandhandlerPort.requestAck(2);"
							}
						}
						Transition tr6: floorRequested -> cp cp1 {
							triggers {
								<floorRequest: cabinePort>
								or
								<floorRequest: serialCommandhandlerPort>
							}
						}
						Transition tr7: cp cp1 -> floorRequested {
							cond {
								"checkFloor(data & 0x7F)"
							}
							action {
								"uint8 mask = 1;"
								""
								"if (data & 0x80) serialCommandhandlerPort.requestAck(1);"
								"data &= 0x7F;"
								"// send a new floor list to indicate"
								"cabinePort.stopIndicateFloors();"
								"mask<<=data;"
								"validFloors &= ~mask;"
								"cabinePort.startIndicateFloors(validFloors);"
								""
								"iCabinePort.floorRequest(data);"
							}
						}
						Transition tr8: my tp1 -> idle {
							triggers {
								<timeout: timer>
							}
							action {
								"cabinePort.stopIndicateFloors();"
							}
						}
						Transition init: initial -> idle
						Transition tr9: floorRequested -> idle {
							triggers {
								<floor: iMainControllerPort>
							}
							action {
								"cabinePort.stopIndicateFloors();"
								"timer.kill();"
							}
						}
						Transition tr10: my tp2 -> my tp2 {
							triggers {
								<floorRequest: cabinePort>
							}
							action {
								"if (data == 0){"
								"iCabinePort.floorRequest(data);"
								"}"
							}
						}
						Transition tr11: waitForCabineRequests -> waitForCabineRequests {
							triggers {
								<floorRelease: serialCommandhandlerPort>
							}
							action {
								"timer.kill();"
								"secTime = data & 0x00FF;"
								"validFloors |= (data >> 8) & 0x00FF;"
								"cabinePort.stopIndicateFloors();"
								""
								"cabinePort.startIndicateFloors(validFloors);"
								"timer.startTimeout(secTime * 1000);"
								"serialCommandhandlerPort.releaseAck(1);"
							}
						}
						Transition tr12: floorRequested -> floorRequested {
							triggers {
								<floorRelease: serialCommandhandlerPort>
							}
							action {
								"timer.kill();"
								"secTime = data & 0x00FF;"
								"validFloors |= (data >> 8) & 0x00FF;"
								"cabinePort.stopIndicateFloors();"
								""
								"cabinePort.startIndicateFloors(validFloors);"
								"timer.startTimeout(secTime * 1000);"
								"serialCommandhandlerPort.releaseAck(1);"
							}
						}
						Transition tr13: my tp3 -> my tp3 {
							triggers {
								<floorRequest: serialCommandhandlerPort>
							}
							action {
								"if ((data & 0x7F) == 0){"
								"\tiCabinePort.floorRequest(data & 0x7F);"
								"\tserialCommandhandlerPort.requestAck(1);"
								"\t}else{"
								"\tserialCommandhandlerPort.requestAck(2);"
								"\t}"
							}
						}
						ChoicePoint cp0
						ChoicePoint cp1
						EntryPoint tp0
						handler TransitionPoint tp1
						handler TransitionPoint tp2
						handler TransitionPoint tp3
						State idle
						State waitForCabineRequests
						State floorRequested
					}
				}
			}
		}
	}

	ActorClass ElevatorTop {
		Structure {
			ActorRef motor: AMotorController
			ActorRef cabine: ACabineControllerWithIndication
			ActorRef top: AElevatorMainController
			ActorRef floors [5]: AFloorController
			Binding motor.ControlPort and top.MotorPort
			Binding top.CabinePort and cabine.ControlPort
			Binding top.FloorPort and floors.ControlPort
			Attribute dummy: uint8
		}
		Behavior { }
	}

	ActorClass Test {
		Structure {
			usercode1 {
				"#include \"msp430f5438a.h\""
			}
			SAP timer: PTimer
		}
		Behavior {
			StateMachine {
				Transition init: initial -> state0 {
					action {
						"timer.startTimer(1000);"
					}
				}
				Transition tr0: state0 -> state0 {
					triggers {
						<timeout: timer>
					}
					action {
						"P10OUT ^= 0x40;"
					}
				}
				State state0
			}
		}
	}
	ActorClass AButtonController {
		Interface {
			Port ControlPort: PButtonControl
		}
		Structure {
			usercode1 {
				"#include \"etPlatform.h\""
			}
			external Port ControlPort
			SAP io_in: PIOBitInput
			SAP io_out: PIOBitOutput
			Attribute buttonId: uint8 = "0xFF"
			Attribute ledId: uint8 = "0xFF"
			Attribute floor: uint8 = "0xFF"
		}
		Behavior {
			Operation initIO_in() {
				"DGPIOData d;"
				"d.channel = (((uint32)floor)<<16) + ((uint32)buttonId);"
				"d.changeMessageEnabled = ET_IOBit_CHANGE_MESSAGE_ON_SET;"
				"d.lastValue = 0;"
				"io_in.init(&d);"
			}
			Operation initIO_out() {
				"uint32 id;"
				"id = (((uint32)floor)<<16) + ((uint32)ledId);"
				"io_out.init(id);"
			}
			Operation sendPressed(data:uint8){
				"ControlPort.pressed();"
			}
			StateMachine {
				Transition tr7: my tp0 -> my tp0 {
					triggers {
						<setButtonId: ControlPort>
					}
					action {
						"buttonId=data;\nif (floor != 0xFF) initIO_in();"
					}
				}
				Transition tr8: my tp0 -> my tp0 {
					triggers {
						<setFloor: ControlPort>
					}
					action {
						"floor=data;\nif(buttonId != 0xFF) initIO_in();\nif(ledId != 0xFF) initIO_out();"
					}
				}
				Transition tr0: my tp1 -> my tp1 {
					triggers {
						<ledOn: ControlPort>
					}
					action {
						"//writeToButtonLed(floor, ledId, ON);"
						"io_out.setBit();"
					}
				}
				Transition tr9: my tp1 -> my tp1 {
					triggers {
						<ledOff: ControlPort>
					}
					action {
						"//writeToButtonLed(floor, ledId, OFF);"
						"io_out.resetBit();"
					}
				}
				Transition tr10: my tp0 -> my tp0 {
					triggers {
						<setLedId: ControlPort>
					}
					action {
						"ledId=data;"
						"if(floor != 0xFF) initIO_out();"
					}
				}
				Transition tr11: my tp1 -> my tp1 {
					triggers {
						<ledToggle: ControlPort>
					}
					action {
						"//writeToButtonLed(floor, ledId, TOGGLE);"
					}
				}
				Transition tr12: my tp2 -> my tp2 {
					triggers {
						<valueChanged: io_in>
					}
					action {
						"sendPressed(data);"
					}
				}
				Transition init: initial -> running
				handler TransitionPoint tp0
				handler TransitionPoint tp1
				handler TransitionPoint tp2
				State running
			}
		}
	}

//	ActorClass AButtonController_old {
//		Interface {
//			Port ControlPort: PButtonControl
//		}
//		Structure {
//			usercode1 {
//				"#include \"etPlatform.h\""
//			}
//			external Port ControlPort
//			SAP timer: PTimer
//			SAP io_in: PIOBit
//			SAP io_out: PIOBit
//			Attribute buttonId: uint8 = "0xFF"
//			Attribute ledId: uint8 = "0xFF"
//			Attribute floor: uint8 = "0xFF"
//		}
//		Behavior {
//			Operation repeatPressed() {
//				"/*do nothing*/"
//			}
//			Operation initIO_in() {
//				"DIOBitData d;"
//				"d.hwId = (((uint32)floor)<<16) + ((uint32)buttonId);"
//				"d.ioType = ET_IOBit_INPUT;"
//				"d.changeMessageEnabled = ET_IOBit_CHANGE_MESSAGE_ON_SET;"
//				"d.lastValue = 0;"
//				"io_in.init(&d);"
//			}
//			Operation initIO_out() {
//				"DIOBitData d;"
//				"d.hwId = (((uint32)floor)<<16) + ((uint32)ledId);"
//				"d.ioType = ET_IOBit_OUTPUT;"
//				"d.changeMessageEnabled = ET_IOBit_NO_CHANGE_MESSAGE;"
//				"d.lastValue = 0;"
//				"io_out.init(&d);"
//			}
//			StateMachine {
//				Transition tr1: released -> cp cp1 {
//					triggers {
//						<timeout: timer>
//					}
//					action {
//						"timer.startTimeout(50);"
//					}
//				}
//				Transition tr3: cp cp1 -> released
//				Transition tr4: cp cp1 -> pressed {
//					cond {
//						"getButtonStatus(floor,buttonId)"
//					}
//					action {
//						"ControlPort.pressed();"
//					}
//				}
//				Transition tr2: pressed -> cp cp0 {
//					triggers {
//						<timeout: timer>
//					}
//					action {
//						"timer.startTimeout(50);"
//					}
//				}
//				Transition tr6: cp cp0 -> released {
//					cond {
//						"!getButtonStatus(floor,buttonId)"
//					}
//					action {
//						"ControlPort.released();"
//					}
//				}
//				Transition tr7: my tp0 -> my tp0 {
//					triggers {
//						<setButtonId: ControlPort>
//					}
//					action {
//						"buttonId=data;\nif (floor != 0xFF) initIO_in();"
//					}
//				}
//				Transition tr8: my tp0 -> my tp0 {
//					triggers {
//						<setFloor: ControlPort>
//					}
//					action {
//						"floor=data;\nif(buttonId != 0xFF) initIO_in();\nif(ledId != 0xFF) initIO_out();"
//					}
//				}
//				Transition init: initial -> released {
//					action {
//						"//timer.startTimeout(50);"
//					}
//				}
//				Transition tr0: my tp1 -> my tp1 {
//					triggers {
//						<ledOn: ControlPort>
//					}
//					action {
//						"//writeToButtonLed(floor, ledId, ON);"
//						"io_out.setBit();"
//					}
//				}
//				Transition tr9: my tp1 -> my tp1 {
//					triggers {
//						<ledOff: ControlPort>
//					}
//					action {
//						"//writeToButtonLed(floor, ledId, OFF);"
//						"io_out.resetBit();"
//					}
//				}
//				Transition tr10: my tp0 -> my tp0 {
//					triggers {
//						<setLedId: ControlPort>
//					}
//					action {
//						"ledId=data;"
//						"if(floor != 0xFF) initIO_out();"
//					}
//				}
//				Transition tr5: cp cp0 -> pressed {
//					action {
//						"repeatPressed();"
//					}
//				}
//				Transition tr11: my tp1 -> my tp1 {
//					triggers {
//						<ledToggle: ControlPort>
//					}
//					action {
//						"//writeToButtonLed(floor, ledId, TOGGLE);"
//					}
//				}
//				Transition tr12: my tp2 -> my tp2 {
//					triggers {
//						<valueChanged: io_in>
//					}
//					action {
//						"ControlPort.pressed();"
//					}
//				}
//				ChoicePoint cp1
//				ChoicePoint cp0
//				handler TransitionPoint tp0
//				handler TransitionPoint tp1
//				handler TransitionPoint tp2
//				State released
//				State pressed
//			}
//		}
//	}

	//	ActorClass AButtonControllerT2 {
	//		Interface {
	//			Port ControlPort: PButtonControl
	//		}
	//		Structure {
	//			usercode1 {
	//				"#include \"etPlatform.h\""
	//			}
	//			external Port ControlPort
	//			SAP timer: PTimer
	//			Attribute buttonId: uint8 = "0xFF"
	//			Attribute ledId: uint8 = "0xFF"
	//			Attribute floor: uint8 = "0xFF"
	//		}
	//		Behavior {
	//			StateMachine {
	//				Transition tr1: released -> cp cp1 {
	//					triggers {
	//						<timeout: timer>
	//					}
	//					action {
	//						"timer.startTimeout(50);"
	//					}
	//				}
	//				Transition tr3: cp cp1 -> released
	//				Transition tr4: cp cp1 -> pressed {
	//					cond {
	//						"getButtonStatus(floor,buttonId)"
	//					}
	//					action {
	//						"ControlPort.pressed();"
	//					}
	//				}
	//				Transition tr2: pressed -> cp cp0 {
	//					triggers {
	//						<timeout: timer>
	//					}
	//					action {
	//						"timer.startTimeout(50);"
	//					}
	//				}
	//				Transition tr5: cp cp0 -> pressed {
	//					action {
	//						"ControlPort.pressed();"
	//					}
	//				}
	//				Transition tr6: cp cp0 -> released {
	//					cond {
	//						"!getButtonStatus(floor,buttonId)"
	//					}
	//					action {
	//						"ControlPort.released();"
	//					}
	//				}
	//				Transition tr7: my tp0 -> my tp0 {
	//					triggers {
	//						<setButtonId: ControlPort>
	//					}
	//					action {
	//						"buttonId=data;"
	//					}
	//				}
	//				Transition tr8: my tp0 -> my tp0 {
	//					triggers {
	//						<setFloor: ControlPort>
	//					}
	//					action {
	//						"floor=data;"
	//					}
	//				}
	//				Transition init: initial -> released {
	//					action {
	//						"timer.startTimeout(50);"
	//					}
	//				}
	//				Transition tr0: my tp1 -> my tp1 {
	//					triggers {
	//						<ledOn: ControlPort>
	//					}
	//					action {
	//						"writeToButtonLed(floor, ledId, ON);"
	//					}
	//				}
	//				Transition tr9: my tp1 -> my tp1 {
	//					triggers {
	//						<ledOff: ControlPort>
	//					}
	//					action {
	//						"writeToButtonLed(floor, ledId, OFF);"
	//					}
	//				}
	//				Transition tr10: my tp0 -> my tp0 {
	//					triggers {
	//						<setLedId: ControlPort>
	//					}
	//					action {
	//						"ledId=data;"
	//					}
	//				}
	//				ChoicePoint cp1
	//				ChoicePoint cp0
	//				handler TransitionPoint tp0
	//				handler TransitionPoint tp1
	//				State released
	//				State pressed
	//			}
	//		}
	//	}
	ActorClass ADoorController {
		Interface {
			Port ControlPort: PDoorControl
		}
		Structure {
			usercode1 {
				"#include \"etPlatform.h\""
			}
			external Port ControlPort
			SAP timer: PTimer
			SAP doorPort: PIORegister8Output
			Attribute id: uint8
			Attribute counter: uint8
		}
		Behavior {
			StateMachine {
				Transition init: initial -> waitForId
				Transition setFloor: waitForId -> close {
					triggers {
						<setFloor: ControlPort>
					}
					action {
						"id=data;\n//writeToDoor(id,0);\ndoorPort.init(((uint32)data) << 16);\ndoorPort.setRegister8(0);"
					}
				}
				Transition tr0: close -> opening {
					triggers {
						<open: ControlPort>
					}
					action {
						"timer.startTimeout(50);"
						"counter=0;"
					}
				}
				Transition tr1: cp cp0 -> open {
					action {
						"//ControlPort.done();"
						"timer.startTimeout(1000);"
					}
				}
				Transition tr2: cp cp0 -> opening {
					cond {
						"counter<11"
					}
					action {
						"timer.startTimeout(50);\n//writeToDoor(id,counter);\ndoorPort.setRegister8(counter);"
					}
				}
				Transition tr3: opening -> cp cp0 {
					triggers {
						<timeout: timer>
					}
					action {
						"counter++;"
					}
				}
				Transition tr4: open -> closing {
					triggers {
						<timeout: timer>
					}
					action {
						"timer.startTimeout(50);"
						"counter=12;"
					}
				}
				Transition tr5: closing -> cp cp1 {
					triggers {
						<timeout: timer>
					}
					action {
						"counter--;"
					}
				}
				Transition tr6: cp cp1 -> close {
					action {
						"//writeToDoor(id,0);\ndoorPort.setRegister8(0);\nControlPort.done();"
					}
				}
				Transition tr7: cp cp1 -> closing {
					cond {
						"counter>0"
					}
					action {
						"timer.startTimeout(50);\n//writeToDoor(id,counter);\ndoorPort.setRegister8(counter);"
					}
				}
				Transition tr8: closing -> opening {
					triggers {
						<open: ControlPort>
					}
				}
				Transition tr9: open -> open {
					triggers {
						<open: ControlPort>
					}
					action {
						"timer.kill();"
						"timer.startTimeout(1000);"
					}
				}
				ChoicePoint cp0
				ChoicePoint cp1
				State waitForId
				State close
				State opening
				State open
				State closing
			}
		}
	}

	ActorClass AFloorController {
		Interface {
			Port ControlPort: PFloorControl
		}
		Structure {
			usercode1 {
				"#include \"etPlatform.h\""
			}
			external Port ControlPort
			conjugated Port UpButtonPort: PButtonControl
			conjugated Port DownButtonPort: PButtonControl
			conjugated Port DoorPort: PDoorControl
			ActorRef door: ADoorController
			ActorRef buttons [2]: AButtonController
			Binding DoorPort and door.ControlPort
			Binding DownButtonPort and buttons.ControlPort
			Binding UpButtonPort and buttons.ControlPort
			Attribute floor: uint8
		}
		Behavior {
			StateMachine {
				Transition init: initial -> doorClosed
				Transition tr0: my tp0 -> my tp0 {
					triggers {
						<setFloor: ControlPort>
					}
					action {
						"floor=data;"
						"UpButtonPort.setFloor(data);"
						"UpButtonPort.setButtonId(UP_BUTTON_ID);"
						"UpButtonPort.setLedId(UP_SWITCH_LED);"
						""
						"DownButtonPort.setFloor(data);"
						"DownButtonPort.setButtonId(DOWN_BUTTON_ID);"
						"DownButtonPort.setLedId(DOWN_SWITCH_LED);"
						""
						"DoorPort.setFloor(data);"
					}
				}
				Transition tr1: doorClosed -> doorMoving {
					triggers {
						<openDoor: ControlPort>
					}
					action {
						"DoorPort.open();"
					}
				}
				Transition tr2: doorMoving -> doorClosed {
					triggers {
						<done: DoorPort>
					}
					action {
						"ControlPort.done();"
					}
				}
				Transition tr5: my tp1 -> my tp1 {
					triggers {
						<requestUpAck: ControlPort>
					}
					action {
						"UpButtonPort.ledOn();"
					}
				}
				Transition tr6: my tp1 -> my tp1 {
					triggers {
						<requestDownAck: ControlPort>
					}
					action {
						"DownButtonPort.ledOn();"
					}
				}
				Transition tr7: my tp2 -> my tp2 {
					triggers {
						<pressed: UpButtonPort>
					}
					action {
						"ControlPort.requestUp();"
					}
				}
				Transition tr8: my tp2 -> my tp2 {
					triggers {
						<pressed: DownButtonPort>
					}
					action {
						"ControlPort.requestDown();"
					}
				}
				Transition tr9: my tp1 -> my tp1 {
					triggers {
						<requestsClear: ControlPort>
					}
					action {
						"DownButtonPort.ledOff();"
						"UpButtonPort.ledOff();"
					}
				}
				Transition tr3: doorMoving -> doorMoving {
					triggers {
						<openDoor: ControlPort>
					}
					action {
						"DoorPort.open();"
					}
				}
				handler TransitionPoint tp0
				handler TransitionPoint tp1
				handler TransitionPoint tp2
				State doorClosed
				State doorMoving
			}
		}
	}

	ActorClass AMotorController {
		Interface {
			Port ControlPort: PMotorControl
		}
		Structure {
			usercode1 {
				"#include \"etPlatform.h\""
			}
			external Port ControlPort
			SAP timer: PTimer
		}
		Behavior {
			StateMachine {
				Transition init: initial -> idle
				Transition tr0: idle -> goinigUp {
					triggers {
						<goUpOneFloor: ControlPort>
					}
					action {
						"timer.startTimeout(50);"
					}
				}
				Transition tr1: goinigUp -> cp cp0 {
					triggers {
						<timeout: timer>
					}
					action {
						"timer.startTimeout(50);"
						"shiftMotorUp();"
					}
				}
				Transition tr2: idle -> goingDown {
					triggers {
						<goDownOneFloor: ControlPort>
					}
					action {
						"timer.startTimeout(50);"
					}
				}
				Transition tr3: cp cp0 -> goinigUp {
					action {
						"timer.startTimeout(50);"
					}
				}
				Transition tr4: cp cp0 -> idle {
					cond {
						"getMotorPosition()"
					}
					action {
						"ControlPort.floorReached(getMotorPosition()&0x07);"
					}
				}
				Transition tr5: goingDown -> cp cp1 {
					triggers {
						<timeout: timer>
					}
					action {
						"timer.startTimeout(50);"
						"shiftMotorDown();"
					}
				}
				Transition tr6: cp cp1 -> goingDown {
					action {
						"timer.startTimeout(50);"
					}
				}
				Transition tr7: cp cp1 -> idle {
					cond {
						"getMotorPosition()"
					}
					action {
						"ControlPort.floorReached(getMotorPosition()&0x07);"
					}
				}
				ChoicePoint cp0
				ChoicePoint cp1
				State idle
				State goinigUp
				State goingDown
			}
		}
	}

	ActorClass AStartGenerator [
	"This is a helper actor. It is responsible to deliver an event in case of a sored request" ] {
		Interface {
			Port ControlPort: PStartGenerator
		}
		Structure {
			external Port ControlPort
		}
		Behavior {
			StateMachine {
				Transition init: initial -> running
				Transition tr0: running -> running {
					triggers {
						<requestCheck: ControlPort>
					}
					action {
						"ControlPort.check();"
					}
				}
				Transition tr1: running -> running {
					triggers {
						<requestCheckDoorStatus: ControlPort>
					}
					action {
						"ControlPort.checkDoorStatus();"
					}
				}
				State running
			}
		}
	}

	ActorClass ACabineController {
		Interface {
			Port ControlPort: PCabineControl
		}
		Structure {
			usercode1 {
				"#include \"etPlatform.h\""
			}
			external Port ControlPort
			conjugated Port DoorPort: PDoorControl
			conjugated Port ButtonPort [5]: PButtonControl
			conjugated Port DoorButtonPort: PButtonControl
			ActorRef door: ADoorController
			ActorRef buttons [5]: AButtonController
			ActorRef doorButton: AButtonControllerRelMsg
			Binding DoorPort and door.ControlPort
			Binding ButtonPort and buttons.ControlPort
			Binding DoorButtonPort and doorButton.ControlPort
		}
		Behavior {
			StateMachine {
				Transition init: initial -> doorClosed {
					action {
						"unsigned char i;"
						"for (i=0;i<5;i++){"
						"\tButtonPort[i].setFloor(i);"
						"\tButtonPort[i].setButtonId(CABINE_BUTTON_ID);"
						"\tButtonPort[i].setLedId(CABINE_SWITCH_LED);"
						"}"
						"DoorPort.setFloor(5);"
						""
						"DoorButtonPort.setButtonId(CABINE_DOOR_BUTTON_ID);"
						"DoorButtonPort.setFloor(0);"
						"DoorButtonPort.setLedId(0);"
					}
				}
				Transition tr0: my tp0 -> my tp0 {
					triggers {
						<set7seg: ControlPort>
					}
					action {
						"writeTo7Seg(data);"
					}
				}
				Transition tr1: doorClosed -> doorMoving {
					triggers {
						<openDoor: ControlPort>
					}
					action {
						"DoorPort.open();"
					}
				}
				Transition tr2: doorMoving -> doorClosed {
					triggers {
						<done: DoorPort>
					}
					action {
						"ControlPort.done();"
					}
				}
				Transition tr7: my tp2 -> my tp2 {
					triggers {
						<floorRequestAck: ControlPort>
					}
					action {
						"ButtonPort[data].ledOn();"
					}
				}
				Transition tr5: my tp2 -> my tp2 {
					triggers {
						<pressed: ButtonPort>
					}
					action {
						"unsigned char idx=((etReplSubPort*)ifitem)->index;"
						"ControlPort.floorRequest(idx);"
					}
				}
				Transition tr6: my tp2 -> my tp2 {
					triggers {
						<floorRequestClear: ControlPort>
					}
					action {
						"ButtonPort[data].ledOff();"
					}
				}
				Transition tr3: doorMoving -> doorMoving {
					triggers {
						<openDoor: ControlPort>
					}
					action {
						"DoorPort.open();"
					}
				}
				Transition tr4: my tp1 -> my tp1 {
					triggers {
						<pressed: DoorButtonPort>
					}
					action {
						"ControlPort.doorRequest();"
					}
				}
				handler TransitionPoint tp0
				handler TransitionPoint tp2
				handler TransitionPoint tp1
				State doorClosed
				State doorMoving
			}
		}
	}

	ActorClass ACabineControllerWithIndication extends ACabineController {
		Structure {
			SAP timer: PTimer
			Attribute indicatorPattern: uint8
		}
		Behavior {
			StateMachine {
				Transition tr11: my tp4 -> my tp4 {
					triggers {
						<timeout: timer>
					}
					action {
						"uint8 i,mask;"
						"mask = 1;"
						""
						"timer.startTimer(200);"
						"for (i=0;i<8;i++){"
						"\tif (indicatorPattern & mask){"
						"\t\tButtonPort[i].ledToggle();"
						"\t\t}\t"
						"\tmask<<=1;"
						"\t}"
					}
				}
				Transition tr12: my tp4 -> my tp4 {
					triggers {
						<startIndicateFloors: ControlPort>
					}
					action {
						"uint8 i,mask;"
						"indicatorPattern=data;"
						"mask = 1;"
						""
						"timer.startTimer(200);"
						"for (i=0;i<8;i++){"
						"\tif (indicatorPattern & mask){"
						"\t\tButtonPort[i].ledOn();"
						"\t\t}\t"
						"\tmask<<=1;"
						"\t}"
					}
				}
				Transition tr8: my tp4 -> my tp4 {
					triggers {
						<stopIndicateFloors: ControlPort>
					}
					action {
						"uint8 i,mask;"
						"mask = 1;"
						""
						"timer.kill();"
						"for (i=0;i<8;i++){"
						"\tif (indicatorPattern & mask){"
						"\t\tButtonPort[i].ledOff();"
						"\t\t}\t"
						"\tmask<<=1;"
						"\t}"
					}
				}
				handler TransitionPoint tp4
			}
		}
	}

	ActorClass ASerialMirrow {
		Structure {
			usercode1 {
				"// uc1"
			}
			usercode2 {
				"// uc2"
			} usercode3 {
			"// uc3
				uint8 ASerialMirrow_staticInstanceCounter = 0;
				"
			}
			SAP com: PSerial
			Attribute instance: uint8
		}
		Behavior {
			StateMachine {
				Transition init: initial -> state0 {
					action {
						"DSerialData d;"
						""
						"instance=ASerialMirrow_staticInstanceCounter++;"
						"com.openChnl(instance+5);"
						""
						"d.len = 7;"
						"d.data[0] = \'H\';"
						"d.data[1] = \'a\';"
						"d.data[2] = \'l\';"
						"d.data[3] = \'l\';"
						"d.data[4] = \'o\';"
						"d.data[5] = \'\\n\';"
						""
						"com.sendData(&d);"
					}
				}
				Transition tr0: state0 -> state0 {
					triggers {
						<dataReceived: com>
					}
					action {
						"com.sendData(data);"
					}
				}
				State state0
			}
		}
	}

	ActorClass ASerialCommandHandler {
		Interface {
			Port applPort: PSerialCommandHandler
		}
		Structure {
			external Port applPort
			SAP com: PSerial
		}
		Behavior {
			StateMachine {
				Transition init: initial -> state0 {
					action {
						"com.openChnl(10);"
					}
				}
				Transition tr0: state0 -> state0 {
					triggers {
						<dataReceived: com>
					}
					action {
						"uint16 h;"
						""
						"switch (data->data[0]){"
						"case 0x01:"
						"\t//released floors"
						"\th = (data->data[1]) << 8;"
						"\t//time"
						"\th |= data->data[2];"
						"\tapplPort.floorRelease(h);"
						"\tbreak;"
						""
						"case 0x02:"
						"\tif (data->data[1] < 5){"
						"\t\t// workaround to indicate floor request via V.24"
						"\t\tdata->data[1] |= 0x80;"
						"\t\tapplPort.floorRequest(data->data[1]);}\t\t"
						"\tbreak;"
						""
						"case 0x03:"
						"\tapplPort.statusRequest();"
						"\tbreak;"
						"default:"
						"break;"
						"};"
					}
				}
				Transition tr1: state0 -> state0 {
					triggers {
						<releaseAck: applPort>
					}
					action {
						"DSerialData d;"
						""
						"d.len = 2;"
						"d.data[0] = 0x01;"
						"d.data[1] = data;"
						""
						"com.sendData(&d);"
					}
				}
				Transition tr2: state0 -> state0 {
					triggers {
						<requestAck: applPort>
					}
					action {
						"DSerialData d;"
						""
						"d.len = 2;"
						"d.data[0] = 0x02;"
						"d.data[1] = data;"
						""
						"com.sendData(&d);"
					}
				}
				Transition tr3: state0 -> state0 {
					triggers {
						<status: applPort>
					}
					action {
						"DSerialData d;"
						""
						"d.len = 4;"
						"d.data[0] = 0x03;"
						"d.data[1] = (data >> 16) & 0x000000FF;"
						"d.data[2] = (data >> 8) & 0x000000FF;"
						"d.data[3] = data  & 0x000000FF;"
						"com.sendData(&d);"
					}
				}
				State state0
			}
		}
	}

	ActorClass AButtonControllerRelMsg extends AButtonController {
		Structure {
			SAP timer:PTimer
		}
		Behavior {
			Operation initIO_in() {
				"DGPIOData d;"
				"d.channel = (((uint32)floor)<<16) + ((uint32)buttonId);"
				"d.changeMessageEnabled = ET_IOBit_CHANGE_MESSAGE_ON_SET | ET_IOBit_CHANGE_MESSAGE_ON_RESET;"
				"d.lastValue = 0;"
				"io_in.init(&d);"
			}
			Operation initIO_out() {
				"uint32 id;"
				"id = (((uint32)floor)<<16) + ((uint32)ledId);"
				"io_out.init(id);"
			}
			Operation sendPressed(data:uint8){
				"if (data == 1) {"
				"	ControlPort.pressed();"
				"	timer.startTimer(100);"
				"	}else{"
				"	timer.kill();"
				"	}"
			}
			
			StateMachine {
				Transition tr1: my tp2 -> my tp2 {
					triggers {
						<timeout: timer>
					}
					action {
						"ControlPort.pressed();"
					}
				}
			}
		}
	}

	ActorClass AGuDManualCode {
		Interface {
			Port p0: PCabineControl
		}
		Structure {
			external Port p0
		}
		Behavior {
			@BehaviorManual
		}
	}

	ActorClass AGuDXYControler {
		Interface {
			conjugated Port x: PGuDTestMotor
			conjugated Port y: PGuDTestMotor
		}
		Structure {
			external Port x
			external Port y
		}
		Behavior {
			StateMachine {
				Transition init: initial -> state0 {
					action {
						"x.startPositionierung();"
						"y.startPositionierung();"
					}
				}
				Transition tr1: state0 -> xFertig {
					triggers {
						<fertigPositionierung: x>
					}
				}
				Transition tr3: xFertig -> fertigPositionierung {
					triggers {
						<fertigPositionierung: y>
					}
				}
				Transition tr0: state0 -> yFertig {
					triggers {
						<fertigPositionierung: y>
					}
				}
				Transition tr2: state0 -> error {
					triggers {
						<error: x>
					}
				}
				Transition tr4: state0 -> error {
					triggers {
						<error: y>
					}
				}
				Transition tr5: yFertig -> fertigPositionierung {
					triggers {
						<fertigPositionierung: x>
					}
				}
				Transition tr6: xFertig -> xFertig {
					triggers {
						<error: y>
					}
				}
				Transition tr7: yFertig -> yFertig {
					triggers {
						<error: x>
					}
				}
				Transition tr8: error -> error {
					triggers {
						<fertigPositionierung: x>
					}
				}
				Transition tr9: error -> error {
					triggers {
						<fertigPositionierung: y>
					}
				}
				Transition tr10: error -> error {
					triggers {
						<error: x>
					}
				}
				Transition tr11: error -> error {
					triggers {
						<error: y>
					}
				}
				State state0
				State xFertig
				State fertigPositionierung
				State yFertig
				State error
			}
		}
	}

	async ActorClass AGuDDataDrivenTest {
		Interface {
			Port dataPort: PDataPort
			conjugated Port dataPortOut: PDataPort
		}
		Structure {
			external Port dataPort
			external Port dataPortOut
		}
		Behavior {
			StateMachine {
				Transition init: initial -> state0
				Transition tr0: state0 -> state1 {
					guard {
						"dataPort.in1==7"
					}
					action {
						"dataPortOut.in2(4);"
					}
				}
				State state0
				State state1
			}
		}
	}

	ProtocolClass PButtonControl {
		incoming {
			Message setButtonId(data: uint8)
			Message setLedId(data: uint8)
			Message setFloor(data: uint8)
			Message ledOn()
			Message ledOff()
			Message ledToggle()
		}
		outgoing {
			Message pressed()
			Message released()
		}
	}

	ProtocolClass PDoorControl {
		incoming {
			Message setFloor(data: uint8) [ "Indicates which HW instance should be addressed from an actor instance." ]
			Message open() [ "Indicates that a door should be opened." ]
			Message close() [ "Indicates to close the door." ]
		}
		outgoing {
			Message done() [ "Indicates that the job (open/close) is finished." ]
		}
	}

	ProtocolClass PCabineControl {
		incoming {
			Message set7seg(data: uint8) [ "Display the provided number at the 7 Segment display." ]
			Message openDoor() [ "Open the cabine door." ]
			Message closeDoor() [ "Close the cabine door." ]
			Message floorRequestAck(data: uint8) [
			"If a floorRequest is received, a ack will be sent. The request LED will be switched on" ]
			Message floorRequestClear(data: uint8) [ "Clear the request LED" ]
			Message startIndicateFloors(data: uint8) [ "start blinking the released LEDs" ]
			Message stopIndicateFloors() [ "stop blinking the LEDs" ]
		}
		outgoing {
			Message floorRequest(data: uint8) [ "The user has requested a floor." ]
			Message doorRequest() [ "The user requests to open the door." ]
			Message done() [ "The requested action is finished." ]
		}
	}

	ProtocolClass PMotorControl [ "PMotorControl provides all messages to control the elevator motor." ] {
		incoming {
			Message goUpOneFloor() [ "Move one floor up." ]
			Message goDownOneFloor() [ "Move one floor down." ]
		}
		outgoing {
			Message floorReached(data: uint8) [ "A floor is reached. Data contains the floor number." ]
		}
	}

	ProtocolClass PFloorControl [ "Protocol to control the floor buttons and LEDs." ] {
		incoming {
			Message setFloor(data: uint8) [ "Set the floor Id to use the correct I/Os" ]
			Message openDoor() [ "Open the floor door." ]
			Message closeDoor() [ "Close the floor door." ]
			Message requestUpAck() [ "Request acknowlege, switch the UpButton LED on." ]
			Message requestDownAck() [ "same" ]
			Message requestsClear() [ "Clear all requests, switch off the LEDs" ]
		}
		outgoing {
			Message requestUp() [ "User has request the elevator for Up." ]
			Message requestDown() [ "User has request the elevator for Down." ]
			Message done() [ "Open/Close door is done." ]
		}
	}

	ProtocolClass PSerialCommandHandler {
		incoming {
			Message status(data: uint32)
			Message releaseAck(data: uint8)
			Message requestAck(data: uint8)
		}
		outgoing {
			Message floorRelease(data: uint16)
			Message floorRequest(data: uint8)
			Message statusRequest()
		}
	}

	ProtocolClass PMainControllerStatus {
		incoming {
			Message getStatus() [ "get the actual status" ]
			Message setIdleFloor(data: uint8) [ "set the idle floor" ]
			Message setIdleTime(data: uint8) [ "set the idle time in seconds, 0 => idle floor deactivated" ]
			Message requestIdle() [ "request a message when idle is reached" ]
			Message requestFloor() [ "request a message when the next requested floor is reached" ]
		}
		outgoing {
			Message status(data: uint32) [ "the actual status" ]
			Message idle() [ "idle state reached" ]
			Message floor(data: uint8) [ "floor is reached" ]
		}
	}

	ProtocolClass PGuDTestMotor {
		incoming {
			Message startPositionierung()
		}
		outgoing {
			Message fertigPositionierung()
			Message error()
		}
		semantics {
			in: startPositionierung ->(out: fertigPositionierung,
			out: error)
		}
	}

	datadriven ProtocolClass PDataPort {
		incoming {
			Message in1(data: uint32)
			Message in2(data: uint32)
			Message in3(data: uint32)
		}
	}

	ProtocolClass PStartGenerator {
		incoming {
			Message requestCheck()
			Message requestCheckDoorStatus()
		}
		outgoing {
			Message check()
			Message checkDoorStatus()
		}
	}

}