RoomModel MessConfAmpelDemo {

	import room.basic.types.* from "etrice_c_modellib/Types.room"

	import room.basic.service.pinterrupt.* from "etrice_c_modellib/PInterrupt.room"

	import room.basic.service.timing.* from "etrice_c_modellib/TimingService.room"

	LogicalSystem MessConfAmpelDemo {
		SubSystemRef main: MainSubSystem
	}

	ProtocolClass POnOff {
		incoming {
			Message on()
			Message off()
		}
	}

	ProtocolClass PUartCtrl {
		incoming {
			Message sendByte(data: uint8)
			Message sendFrame(data: uint8 ref)
			Message receiveByte()
			Message receiveFrame()
			Message init()
		}
		outgoing {
			Message received(data: uint8 ref)
			Message error()
		}
	}

	ActorClass HWAbstractionAmpelDemo {
		Interface {
			Port pedGreenLed: POnOff
			Port pedRedLed: POnOff
			Port carGreenLed: POnOff
			Port carYellowLed: POnOff
			Port carRedLed: POnOff
			Port nucleoGreenLed: POnOff
			conjugated Port button: POnOff
			Port uart: PUartCtrl
		}
		Structure {
			usercode1 {
				"#include \"main.h\""
				"#include \"stm32f0xx_hal.h\""
			}
			Attribute RequestButtonState: uint32
			SAP timer: PTimer
			external Port pedGreenLed
			external Port pedRedLed
			external Port carGreenLed
			external Port carYellowLed
			external Port carRedLed
			external Port nucleoGreenLed
			external Port button
			Binding uart1_isr and uart1.isr
			Binding uart1_error and uart1.errorIsr
			Binding uart and uart1.ctrl
			ActorRef uart1: AUart1
			conjugated Port uart1_isr: PInterrupt
			conjugated Port uart1_error: PInterrupt
		}
		Behavior {
			StateMachine {
				State running
				Transition init0: initial -> running {
					action {
						"timer.startTimer(50);"
						"RequestButtonState=0;"
						""
						"UART1_registerUartPort(uart1_isr.export());"
						"UART1_registerUartErrorPort(uart1_error.export());"
					}
				}
				Transition tr0: running -> running {
					triggers {
						<timeout: timer>
					}
					action {
						"if (RequestButtonState == 0){"
						"\tif (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_0) == GPIO_PIN_SET){"
						"\t\tRequestButtonState=1;"
						"\t\tbutton.on();"
						"\t\t}\t"
						"\t}"
						"\t"
						"if (RequestButtonState == 1){"
						"\tif (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_0) == GPIO_PIN_RESET){"
						"\t\tRequestButtonState=0;"
						"\t\tbutton.off();"
						"\t\t}\t"
						"\t}\t"
					}
				}
				Transition tr1: running -> running {
					triggers {
						<on: nucleoGreenLed>
					}
					action {
						"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);"
					}
				}
				Transition tr2: running -> running {
					triggers {
						<off: nucleoGreenLed>
					}
					action {
						"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);"
					}
				}
				Transition tr3: running -> running {
					triggers {
						<on: pedGreenLed>
					}
					action {
						"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_1, GPIO_PIN_SET);"
					}
				}
				Transition tr4: running -> running {
					triggers {
						<off: pedGreenLed>
					}
					action {
						"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_1, GPIO_PIN_RESET);"
					}
				}
				Transition tr5: running -> running {
					triggers {
						<on: pedRedLed>
					}
					action {
						"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_SET);"
					}
				}
				Transition tr6: running -> running {
					triggers {
						<off: pedRedLed>
					}
					action {
						"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_RESET);"
					}
				}
				Transition tr7: running -> running {
					triggers {
						<on: carGreenLed>
					}
					action {
						"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_SET);"
					}
				}
				Transition tr8: running -> running {
					triggers {
						<off: carGreenLed>
					}
					action {
						"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_RESET);"
					}
				}
				Transition tr9: running -> running {
					triggers {
						<on: carYellowLed>
					}
					action {
						"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);"
					}
				}
				Transition tr10: running -> running {
					triggers {
						<off: carYellowLed>
					}
					action {
						"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_RESET);"
					}
				}
				Transition tr11: running -> running {
					triggers {
						<on: carRedLed>
					}
					action {
						"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_5, GPIO_PIN_SET);"
					}
				}
				Transition tr12: running -> running {
					triggers {
						<off: carRedLed>
					}
					action {
						"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_5, GPIO_PIN_RESET);"
					}
				}
			}
		}
	}

	ActorClass ABlinky {
		Interface {
			conjugated Port led: POnOff
		}
		Structure {
			SAP timer: PTimer
			external Port led
		}
		Behavior {
			StateMachine {
				State off { }
				State on {
					entry {
						"led.on();"
					}
					exit {
						"led.off();"
					}
				}
				Transition init0: initial -> on {
					action {
						"timer.startTimer(400);"
					}
				}
				Transition tr0: off -> on {
					triggers {
						<timeout: timer>
					}
				}
				Transition tr1: on -> off {
					triggers {
						<timeout: timer>
					}
				}
			}
		}
	}

	SubSystemClass MainSubSystem {
		ActorRef appl: Application
		LogicalThread defaultThread
		LayerConnection ref appl satisfied_by timing.timer
		ActorRef timing: ATimingService
	}

	ActorClass AUart1 {
		Interface {
			Port isr: PInterrupt
			Port ctrl: PUartCtrl
			Port errorIsr: PInterrupt
		}
		Structure {
			usercode1 {
				"#include \"main.h\""
			}
			external Port isr
			SAP timer: PTimer
			external Port ctrl
			external Port errorIsr
		}
		Behavior {
			StateMachine {
				State state0
				Transition init: initial -> state0 { }
				Transition tr0: state0 -> state0 {
					triggers {
						<event: isr>
					}
					action {
						"ctrl.received(UART1_getRxBuffer());"
					}
				}
				Transition tr3: state0 -> state0 {
					triggers {
						<receiveByte: ctrl>
					}
					action {
						"UART1_receiveByte();"
					}
				}
				Transition tr4: state0 -> state0 {
					triggers {
						<receiveFrame: ctrl>
					}
					action {
						"UART1_receiveFrame();"
					}
				}
				Transition tr5: state0 -> state0 {
					triggers {
						<sendByte: ctrl>
					}
					action {
						"UART1_sendByte(data);"
					}
				}
				Transition tr6: state0 -> state0 {
					triggers {
						<sendFrame: ctrl>
					}
					action {
						"UART1_sendFrame(data);"
					}
				}
				Transition tr7: state0 -> state0 {
					triggers {
						<init: ctrl>
					}
					action {
						"UART1_initUart();"
					}
				}
				Transition tr8: state0 -> state0 {
					triggers {
						<event: errorIsr>
					}
					action {
						"ctrl.error();"
					}
				}
			}
		}
	}

	ProtocolClass PUartAdapterCtrl {
		incoming {
			Message start()
			Message stop()
			Message setTimeWarp(factor: uint8)
		}
		outgoing {
			Message started()
			Message stopped()
			Message doneSetTimewarp()
		}
	}

	ActorClass APedLightApplication {
		Interface {
			conjugated Port pedRed: POnOff
			conjugated Port pedGreen: POnOff
			conjugated Port carRed: POnOff
			conjugated Port carGreen: POnOff
			conjugated Port carYellow: POnOff
			Port button: POnOff
			Port ctrl: PUartAdapterCtrl
		}
		Structure {
			SAP timer: PTimer
			external Port pedRed
			external Port pedGreen
			external Port carRed
			external Port carGreen
			external Port carYellow
			external Port button
			external Port ctrl
			Attribute timeWarpFactor: int32
		}
		Behavior {
			StateMachine {
				
				
				
				
				State Standby {
					subgraph {
						State On {
							entry {
								"timer.startTimeout(500/timeWarpFactor);"
								"carYellow.on();"
								"pedRed.on();"
							}
							exit {
								"carYellow.off();"
								"pedRed.off();"
							}
						}
						State Off {
							entry {
								"timer.startTimeout(500/timeWarpFactor);"
							}
						}
						EntryPoint tr0
						Transition tr1: my tr0 -> On
						Transition tr2: On -> Off {
							triggers {
								<timeout: timer>
							}
						}
						Transition tr3: Off -> On {
							triggers {
								<timeout: timer>
							}
						}
					}
				}
				State Operational
			{
					subgraph {
						State AllOff {
							entry 
						{
								"pedRed.off();"
								"pedGreen.off();"
								"carRed.off();"
								"carGreen.off();"
								"carYellow.off();"
								"timer.startTimeout(500/timeWarpFactor);"
							}
						}
						State AllRed {
							entry 
						{
								"pedRed.on();"
								"pedGreen.off();"
								"carRed.on();"
								"carYellow.off();"
								"carGreen.off();"
								"timer.startTimeout(1000/timeWarpFactor);"
							}
						}
						State CarRedYellow {
							entry 
						{
								"carRed.on();"
								"carYellow.on();"
								"carGreen.off();"
								"timer.startTimeout(1000/timeWarpFactor);"
							}
						}
						State CarGreen_Idle {
							entry 
						{
								"carRed.off();"
								"carYellow.off();"
								"carGreen.on();"
							}
						}
						EntryPoint tr0
						Transition tr1: my tr0 -> AllOff
						Transition tr2: AllOff -> AllRed {
							triggers {
								<timeout: timer>
							}
						}
						Transition tr3: AllRed -> CarRedYellow {
							triggers {
								<timeout: timer>
							}
						}
					State Request {
							entry {
								"timer.startTimeout(500/timeWarpFactor);"
							}
						}
						State CarYellow {
							entry {
								"carRed.off();"
								"carYellow.on();"
								"carGreen.off();"
								"timer.startTimeout(1000/timeWarpFactor);"
							}
						}
						State CarRed {
							entry {
								"carRed.on();"
								"carYellow.off();"
								"carGreen.off();"
								"timer.startTimeout(2000/timeWarpFactor);"
							}
						}
						State PedGreen {
							entry {
								"pedRed.off();"
								"pedGreen.on();"
								"timer.startTimeout(2000/timeWarpFactor);"
							}
						}
						Transition tr4: CarRedYellow -> CarGreen_Idle {
							triggers {
								<timeout: timer>
							}
						}
						Transition tr5: CarGreen_Idle -> Request {
							triggers {
								<off: button>
							}
						}
						Transition tr6: Request -> CarYellow {
							triggers {
								<timeout: timer>
							}
						}
						Transition tr7: CarYellow -> CarRed {
							triggers {
								<timeout: timer>
							}
						}
						Transition tr8: CarRed -> PedGreen {
							triggers {
								<timeout: timer>
							}
						}
						Transition tr9: PedGreen -> AllRed {
							triggers {
								<timeout: timer>
							}
						}
					}
				}
				Transition init0: initial -> tr0 of Standby {
					action 
				
				{
						"timeWarpFactor=1; // standard: no time warp "
						""
						"pedRed.off();"
						"pedGreen.off();"
						"carRed.off();"
						"carGreen.off();"
						"carYellow.off();"
					}
				}
			Transition tr0: Standby -> tr0 of Operational {
					triggers {
						<off: button>
					}
				}
			}
		}
	}

	ActorClass AUartMirror {
		Interface {
			conjugated Port p0: PUartAdapterCtrl
		}
		Structure {
			external Port p0
		}
		Behavior {
			StateMachine {
				State state0
				Transition init0: initial -> state0
				Transition tr0: state0 -> state0 {
					triggers {
						<started: p0>
					}
					action {
						"p0.send2();"
					}
				}
				Transition tr1: state0 -> state0 {
					triggers {
						<stopped: p0>
					}
					action {
						"p0.send1();"
					}
				}
			}
		}
	}

	ActorClass AUartAdapter {
		Interface {
			conjugated Port uart: PUartCtrl
			conjugated Port ctrl: PUartAdapterCtrl
		}
		Structure {
			usercode3 {
				"uint8_t txData[10];"
				"uint8_t rxData[10];"
			}
			external Port uart
			external Port ctrl
		}
		Behavior {
			StateMachine {
				State state0
				Transition init0: initial -> state0 {
					action {
						"txData[0] = 0x00;"
						"txData[1] = 0x00;"
						"txData[2] = 0x00;"
						"txData[3] = 0x00;"
						"txData[4] = 0x00;"
						"txData[5] = 0x00;"
						""
						"uart.receiveFrame();"
					}
				}
				Transition tr0: state0 -> state0 {
					triggers {
						<received: uart>
					}
					action 
				
				{
						"uart.receiveFrame();\t"
						""
						"switch (data[0]){"
						"\tcase 0x01:"
						"\t\tctrl.start();"
						"\t\tbreak;"
						"\tcase 0x02:"
						"\t\tctrl.stop();"
						"\t\tbreak;"
						"\tcase 0x03:"
						"\t\tctrl.setTimeWarp(data[1]);"
						"\t\tbreak;"
						"\tdefault:;"
						"\tbreak;"
						"\t}\t"
					}
				}
				Transition tr1: state0 -> state0 {
					triggers {
						<started: ctrl>
					}
					action 
				{
						"txData[0] = 0x02;"
						"uart.sendFrame(txData);"
					}
				}
				Transition tr2: state0 -> state0 {
					triggers {
						<stopped: ctrl>
					}
					action 
				{
						"txData[0] = 0x02;"
						"uart.sendFrame(txData);"
					}
				}
			Transition tr3: state0 -> state0 {
					triggers {
						<doneSetTimewarp: ctrl>
					}
					action {
						"txData[0] = 0x03;"
						"uart.sendFrame(txData);"
					}
				}
			}
		}
	}

	ActorClass Application {
		Structure {
			ActorRef hw: HWAbstractionAmpelDemo
			Binding blinky.led and hw.nucleoGreenLed
			ActorRef blinky: ABlinky
			Binding controlAdapter.uart and hw.uart
			ActorRef controlAdapter: AUartAdapter
			Binding tlController.button and hw.button
			Binding tlController.carYellow and hw.carYellowLed
			Binding tlController.carGreen and hw.carGreenLed
			Binding tlController.carRed and hw.carRedLed
			Binding tlController.pedGreen and hw.pedGreenLed
			Binding tlController.pedRed and hw.pedRedLed
			ActorRef tlController: APedLightApplication
		Binding tlController.ctrl and controlAdapter.ctrl
		}
	}

}