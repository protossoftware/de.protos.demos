RoomModel room.basic.service.can {

	import room.basic.types.* from "Types.room"

	import room.basic.service.timing.* from "TimingService.room"

	ActorClass ACANService {
		Interface {
			SPP canTx: PCANTx
			SPP canRx: PCANRx
		}
		Structure {
			usercode1 {
				"/*uc1*/"
			}
			usercode2 {
				"/*uc2*/"
			} usercode3 {
				"/*uc3 */"
				"#include \"pclCANService.h\""
			}
			ServiceImplementation of canTx
			ServiceImplementation of canRx
			SAP timer: PTimer
			Attribute rxData [ 10 ]: DCANData
			Attribute txData [ 10 ]: DCANData
			Attribute pollTime: uint32 = "50"
		}
		Behavior {
			Operation pollAllRxMsgs() {
				"pclCANMsg msg;"
				"uint32 i;"
				"uint8 val;"
				"uint32 numberOfPorts = PCANRxReplPort_getReplication(&(self->constData->canRx));"
				"pclCANReadAllMsgs();"
				"for(i=0;i<numberOfPorts;i++){"
				"	if (PCL_TRUE == pclCANCheckReception(rxData[i].channel, &msg)){"
				"		canRx_msgReceived(i, &msg);"
				"		}"
				"	}"
			}
			StateMachine {
				Transition init: initial -> Operational {
					action {
						"pclCANInitNodes();"
						"timer.startTimer(pollTime);"
					}
				}
				Transition tr0: Operational -> Operational {
					triggers {
						<sendMsg: canTx>
					}
					action {
						"uint32 c;"
						""
						"c =txData[((etReplSubPort*)ifitem)->index].channel;"
						"pclCANSendMsg(c,data);"
					}
				}
				Transition tr1: Operational -> Operational {
					triggers {
						<init: canTx>
					}
					action {
						"txData[((etReplSubPort*)ifitem)->index].channel = data;"
						"pclCANInitMO(data);"
					}
				}
				Transition tr2: Operational -> Operational {
					triggers {
						<init: canRx>
					}
					action {
						"rxData[((etReplSubPort*)ifitem)->index].channel = data;"
						"pclCANInitMO(data);"
					}
				}
				Transition tr3: Operational -> Operational {
					triggers {
						<timeout: timer>
					}
					action {
						"pollAllRxMsgs();"
					}
				}
				Transition tr4: Operational -> Operational {
					triggers {
						<listenOnMsg: canRx>
					}
					action {
						"uint32 c;"
						""
						"c =rxData[((etReplSubPort*)ifitem)->index].channel;"
						"pclCANListenOnMsg(c,data);"
					}
				}
				State Operational
			}
		}
	}

	ActorClass ACANSimulationService {
		Interface {
			SPP canTx: PCANTx
			SPP canRx: PCANRx
		}
		Structure {
			usercode3 {
				"#define CAN_INTERFACE_MASK  0xFFFF0000"
			}
			ServiceImplementation of canTx
			ServiceImplementation of canRx
			SAP timer: PTimer
			Attribute rxData [ 40 ]: DCANDataSimu
			Attribute txData [ 40 ]: DCANDataSimu
			Attribute pollTime: uint32 = "100"
		}
		Behavior {
			Operation pollAllRxMsgs() {
				"pclCANMsg msg;"
				"uint32 i;"
				"uint8 val;"
				"uint32 numberOfPorts = PCANRxReplPort_getReplication(&(self->constData->canRx));"
				"pclCANReadAllMsgs();"
				"for(i=0;i<numberOfPorts;i++){"
				"	if (PCL_TRUE == pclCANCheckReception(rxData[i].channel, &msg)){"
				"		canRx_msgReceived(i, &msg);"
				"		}"
				"	}"
			}
			StateMachine {
				Transition init: initial -> state0 {
					action {
						"// HW"
						"pclCANInitNodes();"
						"timer.startTimer(pollTime);"
					}
				}
				Transition tr1: state0 -> state0 {
					triggers {
						<sendMsg: canTx>
					}
					action {
						"uint32 i;"
						"uint32 c;"
						""
						"// simu"
						"for (i=0;i<PCANRxReplPort_getReplication(&(self->constData->canRx));i++){"
						"\tif (rxData[i].MsgId == data->id){"
						"\t\tif ((rxData[i].channel & CAN_INTERFACE_MASK) != (txData[((etReplSubPort*)ifitem)->index].channel & CAN_INTERFACE_MASK)){"
						"\t\t\tcanRx[i].msgReceived(data);"
						"\t\t\t}"
						"\t\t}"
						"\t}"
						""
						"//HW"
						"c =txData[((etReplSubPort*)ifitem)->index].channel;"
						"pclCANSendMsg(c,data);"
					}
				}
				Transition tr2: state0 -> state0 {
					triggers {
						<init: canTx>
					}
					action {
						"// simu + HW"
						"txData[((etReplSubPort*)ifitem)->index].channel = data;"
						"//HW"
						"pclCANInitMO(data);"
					}
				}
				Transition tr3: state0 -> state0 {
					triggers {
						<resendMsg: canTx>
					}
				}
				Transition tr4: state0 -> state0 {
					triggers {
						<init: canRx>
					}
					action {
						"//simu"
						"rxData[((etReplSubPort*)ifitem)->index].channel = data;"
						""
						"//HW"
						"pclCANInitMO(data);"
					}
				}
				Transition tr5: state0 -> state0 {
					triggers {
						<readMsg: canRx>
					}
				}
				Transition tr6: state0 -> state0 {
					triggers {
						<transmitRequest: canRx>
					}
				}
				Transition tr0: state0 -> state0 {
					triggers {
						<listenOnMsg: canRx>
					}
					action {
						"uint32 c;"
						""
						"// simu"
						"rxData[((etReplSubPort*)ifitem)->index].MsgId = data->id;"
						""
						"//HW"
						"c =rxData[((etReplSubPort*)ifitem)->index].channel;"
						"pclCANListenOnMsg(c,data);"
					}
				}
				Transition tr7: state0 -> state0 {
					triggers {
						<timeout: timer>
					}
					action {
						"pollAllRxMsgs();"
					}
				}
				State state0
			}
		}
	}

	ProtocolClass PCANRx {
		usercode1 {
			"#include \"pclCANService.h\""
			"#define ET_CAN_CHANNEL_NOT_DEFINED			0xFFFFFFFF"
		}
		incoming {
			Message init(data: uint32)
			Message readMsg()
			Message listenOnMsg(data: pclCANMsg)
			Message transmitRequest()
		}
		outgoing {
			Message msgReceived(data: pclCANMsg)
		}
		conjugated PortClass
		{
			handle
			incoming init {
				"ET_MSC_LOGGER_SYNC_ENTRY(\"PCANRxConjPort\", \"init\")"
				"if(data__et != ET_CAN_CHANNEL_NOT_DEFINED) pChannel = data__et;"
				"etPort_sendMessage(self, PCANRx_IN_init, sizeof(uint32), &pChannel);"
				"ET_MSC_LOGGER_SYNC_EXIT"
			}
			Attribute pChannel: uint32 = " ET_CAN_CHANNEL_NOT_DEFINED " [ " must be set by configuration " ]
		}
	}

	ProtocolClass PCANTx {
		usercode1 {
			"#include \"pclCANService.h\""
			"#define ET_CAN_CHANNEL_NOT_DEFINED			0xFFFFFFFF"
		}
		incoming {
			Message init(data: uint32)
			Message sendMsg(data: pclCANMsg)
			Message resendMsg()
		}
		outgoing {
			Message valueChanged(data: uint8)
		}
		conjugated PortClass
		{
			handle
			incoming init {
				"ET_MSC_LOGGER_SYNC_ENTRY(\"PCANTxConjPort\", \"init\")"
				"if(data__et != ET_CAN_CHANNEL_NOT_DEFINED) pChannel=data__et;"
				"etPort_sendMessage(self, PCANTx_IN_init, sizeof(uint32), &pChannel);"
				"ET_MSC_LOGGER_SYNC_EXIT"
			}
			Attribute pChannel: uint32 = " ET_CAN_CHANNEL_NOT_DEFINED " [ " must be set by configuration " ]
		}
	}

	DataClass DCANDataSimu {
		Attribute channel: uint32
		Attribute MsgId: uint32
	}

	DataClass DCANData {
		Attribute channel: uint32 = " ET_CAN_CHANNEL_NOT_DEFINED "
	}

	ExternalType pclCANMsg -> "pclCANMsg"
}